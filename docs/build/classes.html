

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pytRIBS Main Classes &mdash; pytRIBS 0.5.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=1dd76d02"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="pytRIBS" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pytRIBS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Documentation:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">pytRIBS Main Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Land"><code class="docutils literal notranslate"><span class="pre">Land</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Mesh"><code class="docutils literal notranslate"><span class="pre">Mesh</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Met"><code class="docutils literal notranslate"><span class="pre">Met</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Model"><code class="docutils literal notranslate"><span class="pre">Model</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Project"><code class="docutils literal notranslate"><span class="pre">Project</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Results"><code class="docutils literal notranslate"><span class="pre">Results</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.classes.Soil"><code class="docutils literal notranslate"><span class="pre">Soil</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pytribs-base-classes">pytRIBS Base Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor"><code class="docutils literal notranslate"><span class="pre">SoilProcessor</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.compute_ks_decay"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.compute_ks_decay()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.create_soil_map"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.create_soil_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.generate_uniform_groundwater"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.generate_uniform_groundwater()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.get_soil_grids"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.get_soil_grids()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.process_raw_soil"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.process_raw_soil()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.read_soil_table"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.read_soil_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.run_soil_workflow"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.run_soil_workflow()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor.write_soil_table"><code class="docutils literal notranslate"><span class="pre">SoilProcessor.write_soil_table()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor"><code class="docutils literal notranslate"><span class="pre">MetProcessor</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.clip_nldas_grid_mask_to_watershed"><code class="docutils literal notranslate"><span class="pre">MetProcessor.clip_nldas_grid_mask_to_watershed()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.convert_and_write_nldas_timeseries"><code class="docutils literal notranslate"><span class="pre">MetProcessor.convert_and_write_nldas_timeseries()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.create_nldas_grid_mask"><code class="docutils literal notranslate"><span class="pre">MetProcessor.create_nldas_grid_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.extract_nldas_timeseries"><code class="docutils literal notranslate"><span class="pre">MetProcessor.extract_nldas_timeseries()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.get_nldas_elevation"><code class="docutils literal notranslate"><span class="pre">MetProcessor.get_nldas_elevation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.get_nldas_geom"><code class="docutils literal notranslate"><span class="pre">MetProcessor.get_nldas_geom()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.get_nldas_point"><code class="docutils literal notranslate"><span class="pre">MetProcessor.get_nldas_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.polygon_centroid_to_geographic"><code class="docutils literal notranslate"><span class="pre">MetProcessor.polygon_centroid_to_geographic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.met.met.MetProcessor.run_met_workflow"><code class="docutils literal notranslate"><span class="pre">MetProcessor.run_met_workflow()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.land.land.LandProcessor"><code class="docutils literal notranslate"><span class="pre">LandProcessor</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.land.land.LandProcessor.classify_vegetation_height"><code class="docutils literal notranslate"><span class="pre">LandProcessor.classify_vegetation_height()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.land.land.LandProcessor.create_gdf_content"><code class="docutils literal notranslate"><span class="pre">LandProcessor.create_gdf_content()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.land.land.LandProcessor.unsupervised_classification_naip"><code class="docutils literal notranslate"><span class="pre">LandProcessor.unsupervised_classification_naip()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess"><code class="docutils literal notranslate"><span class="pre">Preprocess</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.clip_rasters"><code class="docutils literal notranslate"><span class="pre">Preprocess.clip_rasters()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.clip_streamline"><code class="docutils literal notranslate"><span class="pre">Preprocess.clip_streamline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.convert_stream_raster_to_vector"><code class="docutils literal notranslate"><span class="pre">Preprocess.convert_stream_raster_to_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.create_outlet"><code class="docutils literal notranslate"><span class="pre">Preprocess.create_outlet()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.extract_watershed_and_stream_network"><code class="docutils literal notranslate"><span class="pre">Preprocess.extract_watershed_and_stream_network()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.fill_depressions"><code class="docutils literal notranslate"><span class="pre">Preprocess.fill_depressions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.generate_flow_accumulation_raster"><code class="docutils literal notranslate"><span class="pre">Preprocess.generate_flow_accumulation_raster()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.generate_flow_direction_raster"><code class="docutils literal notranslate"><span class="pre">Preprocess.generate_flow_direction_raster()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.generate_streams_raster"><code class="docutils literal notranslate"><span class="pre">Preprocess.generate_streams_raster()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.generate_watershed_boundary"><code class="docutils literal notranslate"><span class="pre">Preprocess.generate_watershed_boundary()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess.generate_watershed_mask"><code class="docutils literal notranslate"><span class="pre">Preprocess.generate_watershed_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh"><code class="docutils literal notranslate"><span class="pre">GenerateMesh</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.convert_coords_to_mesh"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.convert_coords_to_mesh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.convert_points_to_gdf"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.convert_points_to_gdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.distance_to_nearest_n"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.distance_to_nearest_n()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.extract_points_from_significant_details"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.extract_points_from_significant_details()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.extract_raster_and_wavelet_info"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.extract_raster_and_wavelet_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.filter_coords_within_geometry"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.filter_coords_within_geometry()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.find_max_average_coeffs"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.find_max_average_coeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.find_max_maximum_coeffs"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.find_max_maximum_coeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.generate_meshbuild_input_file"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.generate_meshbuild_input_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.generate_points_along_stream"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.generate_points_along_stream()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.get_extent"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.get_extent()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.interpolate_elevations"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.interpolate_elevations()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.partition_mesh"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.partition_mesh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.plot_mesh"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.plot_mesh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.process_level"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.process_level()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.remove_close_points"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.remove_close_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.mesh.GenerateMesh.write_point_file"><code class="docutils literal notranslate"><span class="pre">GenerateMesh.write_point_file()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.clean_directory"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.clean_directory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.cleanup_container"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.cleanup_container()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_command_in_container"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.execute_command_in_container()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_meshbuild_workflow"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.execute_meshbuild_workflow()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.initialize_docker_client"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.initialize_docker_client()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.pull_image"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.pull_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.run_container"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.run_container()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.start_docker_desktop"><code class="docutils literal notranslate"><span class="pre">MeshBuilderDocker.start_docker_desktop()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate"><code class="docutils literal notranslate"><span class="pre">Evaluate</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate.kling_gupta_efficiency"><code class="docutils literal notranslate"><span class="pre">Evaluate.kling_gupta_efficiency()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate.nash_sutcliffe"><code class="docutils literal notranslate"><span class="pre">Evaluate.nash_sutcliffe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate.percent_bias"><code class="docutils literal notranslate"><span class="pre">Evaluate.percent_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate.root_mean_squared_error"><code class="docutils literal notranslate"><span class="pre">Evaluate.root_mean_squared_error()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.results.read.Read"><code class="docutils literal notranslate"><span class="pre">Read</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.get_element_results"><code class="docutils literal notranslate"><span class="pre">Read.get_element_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.get_element_wb_dataframe"><code class="docutils literal notranslate"><span class="pre">Read.get_element_wb_dataframe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.get_mrf_results"><code class="docutils literal notranslate"><span class="pre">Read.get_mrf_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.get_mrf_wb_dataframe"><code class="docutils literal notranslate"><span class="pre">Read.get_mrf_wb_dataframe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.get_qout_results"><code class="docutils literal notranslate"><span class="pre">Read.get_qout_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.read.Read.read_element_files"><code class="docutils literal notranslate"><span class="pre">Read.read_element_files()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.results.visualize.Viz"><code class="docutils literal notranslate"><span class="pre">Viz</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.visualize.Viz.create_animation"><code class="docutils literal notranslate"><span class="pre">Viz.create_animation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.visualize.Viz.discrete_colormap"><code class="docutils literal notranslate"><span class="pre">Viz.discrete_colormap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.visualize.Viz.plot_water_balance"><code class="docutils literal notranslate"><span class="pre">Viz.plot_water_balance()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.results.waterbalance.WaterBalance"><code class="docutils literal notranslate"><span class="pre">WaterBalance</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.waterbalance.WaterBalance.get_element_water_balance"><code class="docutils literal notranslate"><span class="pre">WaterBalance.get_element_water_balance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.results.waterbalance.WaterBalance.get_mrf_water_balance"><code class="docutils literal notranslate"><span class="pre">WaterBalance.get_mrf_water_balance()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pytribs-shared-and-helper-classes">pytRIBS Shared and Helper Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.shared.aux.Aux"><code class="docutils literal notranslate"><span class="pre">Aux</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.build"><code class="docutils literal notranslate"><span class="pre">Aux.build()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.clean"><code class="docutils literal notranslate"><span class="pre">Aux.clean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.convert_to_datetime"><code class="docutils literal notranslate"><span class="pre">Aux.convert_to_datetime()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.discrete_cmap"><code class="docutils literal notranslate"><span class="pre">Aux.discrete_cmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.fillnodata"><code class="docutils literal notranslate"><span class="pre">Aux.fillnodata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.polygon_centroid_to_geographic"><code class="docutils literal notranslate"><span class="pre">Aux.polygon_centroid_to_geographic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.print_tags"><code class="docutils literal notranslate"><span class="pre">Aux.print_tags()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.rename_file_with_date"><code class="docutils literal notranslate"><span class="pre">Aux.rename_file_with_date()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.run"><code class="docutils literal notranslate"><span class="pre">Aux.run()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.aux.Aux.utm_to_latlong"><code class="docutils literal notranslate"><span class="pre">Aux.utm_to_latlong()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.shared.infile_mixin.Infile"><code class="docutils literal notranslate"><span class="pre">Infile</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.infile_mixin.Infile.create_input_file"><code class="docutils literal notranslate"><span class="pre">Infile.create_input_file()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.shared.inout.InOut"><code class="docutils literal notranslate"><span class="pre">InOut</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_ascii"><code class="docutils literal notranslate"><span class="pre">InOut.read_ascii()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_grid_data_file"><code class="docutils literal notranslate"><span class="pre">InOut.read_grid_data_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_json"><code class="docutils literal notranslate"><span class="pre">InOut.read_json()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_landuse_table"><code class="docutils literal notranslate"><span class="pre">InOut.read_landuse_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_met_sdf"><code class="docutils literal notranslate"><span class="pre">InOut.read_met_sdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_met_station"><code class="docutils literal notranslate"><span class="pre">InOut.read_met_station()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_point_files"><code class="docutils literal notranslate"><span class="pre">InOut.read_point_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_precip_sdf"><code class="docutils literal notranslate"><span class="pre">InOut.read_precip_sdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.read_precip_station"><code class="docutils literal notranslate"><span class="pre">InOut.read_precip_station()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_ascii"><code class="docutils literal notranslate"><span class="pre">InOut.write_ascii()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_grid_data_file"><code class="docutils literal notranslate"><span class="pre">InOut.write_grid_data_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_input_file"><code class="docutils literal notranslate"><span class="pre">InOut.write_input_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_landuse_table"><code class="docutils literal notranslate"><span class="pre">InOut.write_landuse_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_met_sdf"><code class="docutils literal notranslate"><span class="pre">InOut.write_met_sdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_met_station"><code class="docutils literal notranslate"><span class="pre">InOut.write_met_station()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_node_file"><code class="docutils literal notranslate"><span class="pre">InOut.write_node_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_point_file"><code class="docutils literal notranslate"><span class="pre">InOut.write_point_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_precip_sdf"><code class="docutils literal notranslate"><span class="pre">InOut.write_precip_sdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.inout.InOut.write_precip_station"><code class="docutils literal notranslate"><span class="pre">InOut.write_precip_station()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared"><code class="docutils literal notranslate"><span class="pre">Shared</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.convert_to_datetime"><code class="docutils literal notranslate"><span class="pre">Shared.convert_to_datetime()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.get_invariant_properties"><code class="docutils literal notranslate"><span class="pre">Shared.get_invariant_properties()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.merge_parallel_spatial_files"><code class="docutils literal notranslate"><span class="pre">Shared.merge_parallel_spatial_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.merge_parallel_voi"><code class="docutils literal notranslate"><span class="pre">Shared.merge_parallel_voi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.mesh2vtk"><code class="docutils literal notranslate"><span class="pre">Shared.mesh2vtk()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.plot_mesh"><code class="docutils literal notranslate"><span class="pre">Shared.plot_mesh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.read_input_file"><code class="docutils literal notranslate"><span class="pre">Shared.read_input_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.read_node_list"><code class="docutils literal notranslate"><span class="pre">Shared.read_node_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.read_reach_file"><code class="docutils literal notranslate"><span class="pre">Shared.read_reach_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared.read_voi_file"><code class="docutils literal notranslate"><span class="pre">Shared.read_voi_file()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytRIBS.shared.shared_mixin.Meta"><code class="docutils literal notranslate"><span class="pre">Meta</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pytRIBS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pytRIBS Main Classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/classes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pytribs-main-classes">
<h1>pytRIBS Main Classes<a class="headerlink" href="#pytribs-main-classes" title="Link to this heading"></a></h1>
<dl class="py class" id="module-pytRIBS.classes">
<dt class="sig sig-object py" id="pytRIBS.classes.Land">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Land</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Land" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pytRIBS.land.land.LandProcessor" title="pytRIBS.land.land.LandProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">LandProcessor</span></code></a></p>
<p>pytRIBS Land Class.</p>
<p>This class handles land-related data and options for the tRIBS model. It manages attributes related to land mapping,
land tables, and land use grids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_file</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to the input file containing the necessary options for initializing the <cite>Land</cite> class attributes.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – Metadata associated with the <cite>Land</cite> instance.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>landmapname</strong> (<em>str</em>) – The name of the land map file.</p></li>
<li><p><strong>landtablename</strong> (<em>str</em>) – The name of the land table file.</p></li>
<li><p><strong>lugrid</strong> (<em>str</em>) – The path to the LUGRID file.</p></li>
<li><p><strong>optlanduse</strong> (<em>int</em>) – Option for land use.</p></li>
<li><p><strong>optluintercept</strong> (<em>int</em>) – Option for land use interpolation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Mesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preprocess_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_mesh_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Mesh" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A pytRIBS Mesh Class.</p>
<p>This class manages the creation and processing of mesh data for tRIBS simulations. It handles preprocessing of
watershed and stream network data, and integrates with mesh generation routines. For more details see base classes
and example below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>preprocess_args</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Arguments for initializing the Preprocess class. Required if <cite>generate_mesh_args</cite> is provided.</p></li>
<li><p><strong>generate_mesh_args</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Arguments for initializing the GenerateMesh class. Must be provided if <cite>preprocess_args</cite> is given.</p></li>
<li><p><strong>input_file</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to the input file for initializing attributes.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – Metadata associated with the mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pointfilename</strong> (<em>str</em>) – The name of the file containing the mesh points.</p></li>
<li><p><strong>graphfile</strong> (<em>str</em>) – The name of the file containing the mesh graph.</p></li>
<li><p><strong>optmeshinput</strong> (<em>int</em>) – Option flag for mesh input processing.</p></li>
<li><p><strong>graphoption</strong> (<em>int</em>) – Option for graph generation.</p></li>
<li><p><strong>demfile</strong> (<em>str</em>) – The name of the file containing the Digital Elevation Model (DEM) data.</p></li>
<li><p><strong>preprocess</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Preprocess</span></code>, optional) – An instance of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Preprocess</span></code> class used for initial data extraction and processing.</p></li>
<li><p><strong>mesh_generator</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateMesh</span></code>, optional) – An instance of the <code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateMesh</span></code> class used for mesh generation.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>To create and use an instance of the <cite>Mesh</cite> class:
TODO UPDATE!
&gt;&gt;&gt; mesh = Mesh(preprocess_args=(arg1, arg2, arg3), generate_mesh_args=(arg4, arg5, arg6, arg7))
&gt;&gt;&gt; print(mesh.pointfilename)
‘path/to/pointfile’
&gt;&gt;&gt; print(mesh.demfile)
‘path/to/demfile’</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Met">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Met</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Met" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pytRIBS.met.met.MetProcessor" title="pytRIBS.met.met.MetProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetProcessor</span></code></a></p>
<p>A pytRIBS Met Class.</p>
<p>This class handles the meteorological data for tRIBS simulations. It initializes various parameters related to
meteorological stations, rain files, and other related metadata. The class is used to configure and manage the
meteorological input options required for the simulation.</p>
<blockquote>
<div><p>Parameters</p>
</div></blockquote>
<dl class="simple">
<dt>meta<span class="classifier">dict, optional</span></dt><dd><p>Metadata associated with the <cite>Met</cite> instance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hydrometstations</strong> (<em>str</em>) – The path or name of the file containing hydrometeorological station data.</p></li>
<li><p><strong>gaugestations</strong> (<em>str</em>) – The path or name of the file containing gauge station data.</p></li>
<li><p><strong>hydrometbasename</strong> (<em>str</em>) – The base name for hydrometeorological data files.</p></li>
<li><p><strong>rainfile</strong> (<em>str</em>) – The path or name of the file containing rainfall data.</p></li>
<li><p><strong>hydrometgrid</strong> (<em>str</em>) – The path or name of the file containing the hydrometeorological grid data.</p></li>
<li><p><strong>metdataoption</strong> (<em>int</em>) – Option flag for meteorological data processing.</p></li>
<li><p><strong>rainsource</strong> (<em>str</em>) – The source of the rainfall data.</p></li>
<li><p><strong>gaugebasename</strong> (<em>str</em>) – The base name for gauge data files.</p></li>
<li><p><strong>rainextension</strong> (<em>str</em>) – The file extension for the rainfall data files.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Model">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">met</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">land</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">soil</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Model" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pytRIBS.shared.infile_mixin.Infile" title="pytRIBS.shared.infile_mixin.Infile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Infile</span></code></a>, <a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared" title="pytRIBS.shared.shared_mixin.Shared"><code class="xref py py-class docutils literal notranslate"><span class="pre">Shared</span></code></a>, <a class="reference internal" href="#pytRIBS.shared.aux.Aux" title="pytRIBS.shared.aux.Aux"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aux</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ModelProcessor</span></code>, <a class="reference internal" href="#pytRIBS.mesh.mesh.Preprocess" title="pytRIBS.mesh.mesh.Preprocess"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preprocess</span></code></a>, <a class="reference internal" href="#pytRIBS.shared.inout.InOut" title="pytRIBS.shared.inout.InOut"><code class="xref py py-class docutils literal notranslate"><span class="pre">InOut</span></code></a></p>
<p>pytRIBS Model class.</p>
<p>This class provides access to the underlying framework of a tRIBS (TIN-based Real-time Integrated Basin
Simulator) simulation. The Model class can be initialized at the top-level to
facilitate model setup, simulation, post-processing, and can be used for manipulating and generating multiple
simulations efficiently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_file</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to a template <cite>.in</cite> file. Default is <cite>None</cite>.</p></li>
<li><p><strong>met</strong> (<em>object</em><em>, </em><em>optional</em>) – pytRIBS Met Class object Default is <cite>None</cite>.</p></li>
<li><p><strong>land</strong> (<em>object</em><em>, </em><em>optional</em>) – pytRIBS Land object. Default is <cite>None</cite>.</p></li>
<li><p><strong>soil</strong> (<em>object</em><em>, </em><em>optional</em>) – pytRIBS Soil object. Default is <cite>None</cite>.</p></li>
<li><p><strong>mesh</strong> (<em>object</em><em>, </em><em>optional</em>) – pytRIBS Mesh object. Default is <cite>None</cite>.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – pytRIBS Meta object Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>input_options</strong> (<em>dict</em>) – A dictionary of the necessary keywords for a tRIBS <cite>.in</cite> file.</p></li>
<li><p><strong>model_input_file</strong> (<em>str</em>) – Path to a template <cite>.in</cite> file with the specified paths for model results, inputs, etc.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Project">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Project" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>pytRIBS Project Class for managing directories and metadata in a specified root directory.</p>
<p>This class initializes with a base directory, a project name, and an EPSG code. It sets up a
predefined set of directories for data, results, and various sub-categories. It also provides
functionality to create these directories if they do not already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base_dir</strong> (<em>str</em>) – The base directory path for the project.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the project.</p></li>
<li><p><strong>epsg</strong> (<em>int</em>) – The EPSG code representing the coordinate system.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>base_dir</strong> (<em>str</em>) – The base directory where all project-related directories will be created.</p></li>
<li><p><strong>meta</strong> (<em>dict</em>) – A dictionary to store metadata about the project, including ‘Name’ and ‘EPSG’.</p></li>
<li><p><strong>directories</strong> (<em>dict</em>) – A dictionary defining the structure of directories to be created within the base directory.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Results">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Results" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pytRIBS.shared.infile_mixin.Infile" title="pytRIBS.shared.infile_mixin.Infile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Infile</span></code></a>, <a class="reference internal" href="#pytRIBS.shared.shared_mixin.Shared" title="pytRIBS.shared.shared_mixin.Shared"><code class="xref py py-class docutils literal notranslate"><span class="pre">Shared</span></code></a>, <a class="reference internal" href="#pytRIBS.results.waterbalance.WaterBalance" title="pytRIBS.results.waterbalance.WaterBalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">WaterBalance</span></code></a>, <a class="reference internal" href="#pytRIBS.results.read.Read" title="pytRIBS.results.read.Read"><code class="xref py py-class docutils literal notranslate"><span class="pre">Read</span></code></a>, <a class="reference internal" href="#pytRIBS.results.visualize.Viz" title="pytRIBS.results.visualize.Viz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Viz</span></code></a>, <a class="reference internal" href="#pytRIBS.results.evaluate.Evaluate" title="pytRIBS.results.evaluate.Evaluate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Evaluate</span></code></a></p>
<p>pytRIBS Results Class.</p>
<p>This class provides a framework for analyzing and visualizing individual tRIBS simulations. It takes an instance of
the <cite>Simulation</cite> class and provides time-series and water balance analysis of the model results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_file</strong> (<em>str</em><em>, </em><em>required</em>) – Path to the input file containing the necessary options for initializing the <cite>Results</cite> class attributes.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – Metadata associated with the <cite>Results</cite> instance.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>options</strong> (<em>dict</em>) – A dictionary of input options for the tRIBS model run.</p></li>
<li><p><strong>element</strong> (<em>dict</em>) – A dictionary for storing elements related to the results.</p></li>
<li><p><strong>mrf</strong> (<em>dict</em>) – A dictionary containing <cite>mrf</cite> and <cite>waterbalance</cite>, which are initialized to <cite>None</cite>.</p></li>
<li><p><strong>meta</strong> (<em>dict, optional</em>) – Metadata dictionary for additional information. Default is <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.classes.Soil">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.classes.</span></span><span class="sig-name descname"><span class="pre">Soil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.classes.Soil" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pytRIBS.soil.soil.SoilProcessor" title="pytRIBS.soil.soil.SoilProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SoilProcessor</span></code></a></p>
<p>pytRIBS Soil Class.</p>
<p>This class handles soil-related data and options for the tRIBS model. It manages attributes related to soil
mapping, soil tables, and groundwater files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_file</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to the input file containing the necessary options for initializing the <cite>Soil</cite> class attributes.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – Metadata associated with the <cite>Soil</cite> instance.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>soilmapname</strong> (<em>str</em>) – The name of the soil map file.</p></li>
<li><p><strong>soiltablename</strong> (<em>str</em>) – The name of the soil table file.</p></li>
<li><p><strong>scgrid</strong> (<em>str</em>) – The path to the SCGRID file.</p></li>
<li><p><strong>optsoiltype</strong> (<em>int</em>) – Option for soil type.</p></li>
<li><p><strong>optgroundwater</strong> (<em>int</em>) – Option for groundwater.</p></li>
<li><p><strong>optgwfile</strong> (<em>int</em>) – Option for groundwater file.</p></li>
<li><p><strong>optbedrock</strong> (<em>int</em>) – Option for bedrock.</p></li>
<li><p><strong>bedrockfile</strong> (<em>str</em>) – The path to the bedrock file.</p></li>
<li><p><strong>gwaterfile</strong> (<em>str</em>) – The path to the groundwater file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="pytribs-base-classes">
<h1>pytRIBS Base Classes<a class="headerlink" href="#pytribs-base-classes" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.soil.soil.</span></span><span class="sig-name descname"><span class="pre">SoilProcessor</span></span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor" title="Link to this definition"></a></dt>
<dd><p>Methods for pytRIBS Soil Class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.compute_ks_decay">
<span class="sig-name descname"><span class="pre">compute_ks_decay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.compute_ks_decay" title="Link to this definition"></a></dt>
<dd><p>Produces a raster for the conductivity decay parameter <cite>f</cite>, following Ivanov et al., 2004.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_input</strong> (<em>dict</em><em> or </em><em>str</em>) – <p>If a dictionary, it should contain keys “depth” and “path” for each soil property.
Depth should be provided in units of mm. The format of the dictionary list should follow
this structure (from shallowest to deepest):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/25_mm_ks&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="o">...</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">800</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/800_mm_ks&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p>If a string is provided, it is treated as the path to a configuration file. The configuration
file must be written in JSON format.</p>
</p></li>
<li><p><strong>output</strong> (<em>str</em>) – Location to save the raster with the conductivity decay parameter <cite>f</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This function saves the generated raster to the specified <cite>output</cite> location.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To generate a raster using a dictionary for <cite>grid_input</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/25_mm_ks&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">800</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/800_mm_ks&#39;</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;path/to/output_raster.tif&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_ks_decay</span><span class="p">(</span><span class="n">grid_input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
<p>To generate a raster using a configuration file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="s2">&quot;path/to/config_file.json&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;path/to/output_raster.tif&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_ks_decay</span><span class="p">(</span><span class="n">grid_input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.create_soil_map">
<span class="sig-name descname"><span class="pre">create_soil_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.create_soil_map" title="Link to this definition"></a></dt>
<dd><p>Writes out an ASCII file with soil classes assigned by soil texture classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_input</strong> (<em>list</em><em> of </em><em>dict</em><em> or </em><em>str</em>) – <p>If a dictionary list, each dictionary should contain keys “grid_type” and “path” for each soil property.
The format of the dictionary list is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;sand&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/sand_grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;clay&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/clay_grid&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p>If a string is provided, it is treated as the path to a JSON configuration file containing grid types and output file paths.</p>
</p></li>
<li><p><strong>output</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the ASCII soil map will be saved. If not provided, the default output file will be used (<cite>‘soil_class.soi’</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This function does not return any value. It writes an ASCII file with soil classifications to the specified <cite>output</cite> path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To create a soil map using a dictionary list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;sand&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/sand_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;clay&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/clay_grid&#39;</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">create_soil_map</span><span class="p">(</span><span class="n">grid_input</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;path/to/soil_map.asc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a soil map using a configuration file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="s2">&quot;path/to/config_file.json&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">create_soil_map</span><span class="p">(</span><span class="n">grid_input</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.generate_uniform_groundwater">
<span class="sig-name descname"><span class="pre">generate_uniform_groundwater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed_boundary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.generate_uniform_groundwater" title="Link to this definition"></a></dt>
<dd><p>Generates a uniform groundwater raster file within the specified watershed boundary.</p>
<p>This method creates a raster file with uniform groundwater values over the extent of the given
watershed boundary. The raster file can be written to a specified filename or to a default filename
from an attribute if no filename is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>watershed_boundary</strong> (<em>GeoDataFrame</em>) – A GeoDataFrame representing the watershed boundary. It should include a ‘bounds’ property to
determine the raster extent.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – The uniform groundwater value to be written to the raster file.</p></li>
<li><p><strong>filename</strong> (<em>str</em><em>, </em><em>optional</em>) – The path to the output file. If not provided, the filename will be retrieved from the <cite>gwaterfile</cite>
attribute of the object.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>filename</cite> is not provided, the method attempts to use the <cite>gwaterfile</cite> attribute from the object.</p></li>
<li><p>The raster file is written with a single cell covering the entire extent of the watershed boundary.</p></li>
<li><p>The raster format includes the number of columns, rows, and cell size, as well as the specified groundwater value.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">generate_uniform_groundwater</span><span class="p">(</span><span class="n">watershed_gdf</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="s1">&#39;output_file.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>filename</cite> cannot be determined and <cite>gwaterfile</cite> is not set in the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.get_soil_grids">
<span class="sig-name descname"><span class="pre">get_soil_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bbox</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">soil_vars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.get_soil_grids" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.process_raw_soil">
<span class="sig-name descname"><span class="pre">process_raw_soil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ks_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.process_raw_soil" title="Link to this definition"></a></dt>
<dd><p>Writes ASCII grids for Ks, theta_s, theta_r, psib, and m from gridded soil data for sand, silt, clay, bulk density, and volumetric water content at 33 and 1500 kPa.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_input</strong> (<em>list</em><em> of </em><em>dict</em><em> or </em><em>str</em>) – <p>If a dictionary list, each dictionary should contain the keys “grid_type” and “path” for each soil property.
The format of the dictionary list follows this structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;sand_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;silt_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;clay_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;bulk_density&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;vwc_33&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">},</span>
 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;vwc_1500&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/grid&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p>If a string is provided, it is treated as the path to a JSON configuration file.</p>
</p></li>
<li><p><strong>output</strong> (<em>list</em><em>, </em><em>optional</em>) – List of output file names for different soil properties. The list should have exactly 5 file names corresponding to different soil properties.</p></li>
<li><p><strong>ks_only</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, only write rasters for Ks. This is useful when using the <cite>compute_decay_ks</cite> function.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The <cite>grid_input</cite> key should contain a list of dictionaries, each specifying a grid type and its corresponding file path.</p></li>
<li><p>The <cite>output</cite> list should contain exactly 5 output file names for different soil properties.</p></li>
<li><p>The file paths in the <cite>grid_input</cite> list should be valid, and the <cite>output</cite> list should have the correct number of file names.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>To write all soil property grids:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;sand_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/sand_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;silt_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/silt_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;clay_fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/clay_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;bulk_density&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/bulk_density_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;vwc_33&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/vwc_33_grid&#39;</span><span class="p">},</span>
<span class="gp">... </span>              <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;vwc_1500&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;path/to/vwc_1500_grid&#39;</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ks_output.asc&#39;</span><span class="p">,</span> <span class="s1">&#39;theta_s_output.asc&#39;</span><span class="p">,</span> <span class="s1">&#39;theta_r_output.asc&#39;</span><span class="p">,</span> <span class="s1">&#39;psib_output.asc&#39;</span><span class="p">,</span> <span class="s1">&#39;m_output.asc&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">your_function_name</span><span class="p">(</span><span class="n">grid_input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
<p>To write only Ks raster:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_input</span> <span class="o">=</span> <span class="s2">&quot;path/to/config.json&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ks_output.asc&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">your_function_name</span><span class="p">(</span><span class="n">grid_input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">ks_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.read_soil_table">
<span class="sig-name descname"><span class="pre">read_soil_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">textures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.read_soil_table" title="Link to this definition"></a></dt>
<dd><p>Reads a Soil Reclassification Table Structure (<a href="#id1"><span class="problematic" id="id2">*</span></a>.sdt) file.</p>
<p>The .sdt file contains parameters such as:
- ID, Ks, thetaS, thetaR, m, PsiB, f, As, Au, n, ks, Cs, and optionally soil texture.</p>
<p>The method reads the specified soil table file and returns a list of dictionaries representing
the soil types and their associated parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>textures</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the method will read and include texture classes in the returned data. Default is False.</p></li>
<li><p><strong>file_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path to the soil table (.sdt file). If not provided, it defaults to <cite>self.soiltablename[“value”]</cite>.
If <cite>self.soiltablename[“value”]</cite> is also None, the method will print an error message and return None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A list of dictionaries, where each dictionary represents a soil type and its associated parameters.
Each dictionary contains the following keys:
- “ID” : str, soil type ID
- “Ks” : float, saturated hydraulic conductivity
- “thetaS” : float, saturated water content
- “thetaR” : float, residual water content
- “m” : float, parameter related to soil pore size distribution
- “PsiB” : float, bubbling pressure
- “f” : float, hydraulic decay parameter
- “As” : float, saturated anisotropy ratio
- “Au” : float, unsaturated anisotropy ratio
- “n” : float, porosity of the soil
- “ks” : float, volumetric heat conductivity
- “Cs” : float, soil heat capacity
- “Texture” : str, texture class (only if <cite>textures=True</cite> is passed)</p>
<p>If the file does not conform to the standard .sdt format or the number of soil types doesn’t match the specified count,
an error message will be printed, and the function returns None.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dict or None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Reading a soil table without textures:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">soil_list</span> <span class="o">=</span> <span class="n">read_soil_table</span><span class="p">(</span><span class="n">textures</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="s2">&quot;path/to/soil_table.sdt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">soil_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;Ks&quot;</span><span class="p">])</span>
<span class="go">0.0001</span>
</pre></div>
</div>
<p>Reading a soil table with textures:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">soil_list</span> <span class="o">=</span> <span class="n">read_soil_table</span><span class="p">(</span><span class="n">textures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="s2">&quot;path/to/soil_table_with_textures.sdt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">soil_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;Texture&quot;</span><span class="p">])</span>
<span class="go">&#39;Sandy Loam&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.run_soil_workflow">
<span class="sig-name descname"><span class="pre">run_soil_workflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.run_soil_workflow" title="Link to this definition"></a></dt>
<dd><p>Executes the soil processing workflow for the given watershed.</p>
<p>This method performs a series of operations to process soil data, including filling missing values,
processing raw soil grids, computing soil parameters, and generating soil maps. It assumes specific
file structures and parameters for soil processing and outputs the results to the specified directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>watershed</strong> (<em>GeoDataFrame</em>) – A GeoDataFrame representing the watershed boundary. It must contain a ‘bounds’ property for
determining the spatial extent of the data.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – The directory where output files will be saved.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method changes the current working directory to <cite>output_dir</cite> for processing and then restores
the original directory.</p></li>
<li><p>Soil grids are processed for various depths and soil variables.</p></li>
<li><p>The method creates a soil map, writes a soil table file, and generates a configuration file (<cite>scgrid.gdf</cite>)
with paths to the processed soil data.</p></li>
<li><dl class="simple">
<dt>Workflow steps:</dt><dd><ol class="arabic simple">
<li><p>Retrieves soil grid files based on the bounding box from the <cite>watershed</cite> GeoDataFrame.</p></li>
<li><p>Fills missing data in the soil grids.</p></li>
<li><p>Processes raw soil data for specified depths and variables.</p></li>
<li><p>Computes soil hydraulic conductivity decay parameters.</p></li>
<li><p>Creates a soil classification map.</p></li>
<li><p>Writes a soil table file with texture information.</p></li>
<li><p>Generates a configuration file for soil grid data (<cite>scgrid.gdf</cite>).</p></li>
</ol>
</dd>
</dl>
</li>
</ul>
<p class="rubric">Examples</p>
<p>To run the soil processing workflow:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">run_soil_workflow</span><span class="p">(</span><span class="n">watershed_gdf</span><span class="p">,</span> <span class="s1">&#39;/path/to/output_dir&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>FileNotFoundError</strong> – If any of the required input files cannot be found.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.soil.soil.SoilProcessor.write_soil_table">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_soil_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">soil_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">textures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.soil.soil.SoilProcessor.write_soil_table" title="Link to this definition"></a></dt>
<dd><p>Writes out Soil Reclassification Table(<a href="#id3"><span class="problematic" id="id4">*</span></a>.sdt) file with the following format:
#Types #Params
ID Ks thetaS thetaR m PsiB f As Au n ks Cs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>soil_list</strong> – List of dictionaries containing soil information specified by .sdt structure above.</p></li>
<li><p><strong>file_path</strong> – Path to save <a href="#id5"><span class="problematic" id="id6">*</span></a>.sdt file.</p></li>
<li><p><strong>textures</strong> – Optional True/False for writing texture classes to the .sdt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.met.met.</span></span><span class="sig-name descname"><span class="pre">MetProcessor</span></span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor" title="Link to this definition"></a></dt>
<dd><p>Framework for Met Class. See classes.py</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.clip_nldas_grid_mask_to_watershed">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clip_nldas_grid_mask_to_watershed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.clip_nldas_grid_mask_to_watershed" title="Link to this definition"></a></dt>
<dd><p>Clip a target GeoDataFrame (watershed) by each polygon in the pixel GeoDataFrame (mask), and reproject to the appropriate UTM zone.</p>
<p>This method clips the input <cite>watershed</cite> GeoDataFrame by the pixel polygons in the <cite>mask</cite> GeoDataFrame. It calculates the
appropriate UTM zone for the <cite>watershed</cite> and reprojects the clipped geometries to UTM or Web Mercator based on location.
The method then calculates the centroids and geographic coordinates (longitude, latitude) of the clipped geometries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame containing the pixel polygons from the NLDAS-2-2 grid.</p></li>
<li><p><strong>watershed</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame representing the watershed to be clipped by the pixel polygons.</p></li>
<li><p><strong>epsg</strong> (<em>int</em>) – The EPSG code for the coordinate reference system used for geographic coordinates (longitude, latitude).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>clipped_watershed<span class="classifier">geopandas.GeoDataFrame</span></dt><dd><p>The watershed GeoDataFrame clipped by the pixel polygons, reprojected to UTM coordinates, and containing
additional columns for centroids (x, y), geographic coordinates (longitude, latitude), and area.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>utm_crs<span class="classifier">str</span></dt><dd><p>The EPSG code of the UTM zone or Web Mercator projection used for the clipped geometries.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method first checks the UTM zone of the watershed and determines if it spans multiple UTM zones or hemispheres.</p></li>
<li><p>If the watershed spans multiple UTM zones or hemispheres, the geometries are projected to Web Mercator (EPSG:3857).</p></li>
<li><p>The resulting clipped GeoDataFrame includes the centroid coordinates (x, y) in UTM and the geographic coordinates
(longitude, latitude) after transforming from UTM to the given EPSG code.</p></li>
<li><p>The method also calculates the area of each clipped geometry, which can be used for thresholding in subsequent analysis.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.convert_and_write_nldas_timeseries">
<span class="sig-name descname"><span class="pre">convert_and_write_nldas_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_dfs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">station_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gmt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">met_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precip_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.convert_and_write_nldas_timeseries" title="Link to this definition"></a></dt>
<dd><p>Convert NLDAS-2-2 timeseries data to UTM coordinates and prepare for tRIBS input.</p>
<p>This function processes NLDAS-2-2 timeseries data from multiple stations, converts the coordinates to UTM,
and prepares the data for tRIBS model input. The processed data is saved to meteorological and precipitation
files in the specified directories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_dfs</strong> (<em>list</em><em> of </em><em>pandas.DataFrame</em>) – A list of DataFrames, each containing NLDAS-2-2 timeseries data with columns such as ‘date’, ‘psurf’,
‘wind_u’, ‘wind_v’, ‘temp’, ‘humidity’, ‘rsds’, and ‘prcp’.</p></li>
<li><p><strong>station_coords</strong> (<em>list</em><em> of </em><em>tuples</em>) – A list of tuples, each containing the (longitude, latitude, elevation) for each station.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Prefix for the output filenames.</p></li>
<li><p><strong>met_path</strong> (<em>str</em>) – Directory path where meteorological files will be saved.</p></li>
<li><p><strong>precip_path</strong> (<em>str</em>) – Directory path where precipitation files will be saved.</p></li>
<li><p><strong>gmt</strong> (<em>int</em>) – GMT offset for the data.</p></li>
<li><p><strong>utm_epsg</strong> (<em>str</em>) – EPSG code for the UTM coordinate system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This function does not return anything. The transformed timeseries data and station details are written
to the specified output files.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function assumes that the input NLDAS-2 data is structured in a specific way and that the stations’
geographic coordinates (longitude, latitude) need to be converted to UTM coordinates using the provided EPSG code.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.create_nldas_grid_mask">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_nldas_grid_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.create_nldas_grid_mask" title="Link to this definition"></a></dt>
<dd><p>Create polygons representing each pixel in a grid based on GeoTransform parameters.</p>
<p>This method generates a grid of polygons representing each pixel in the input xarray dataset, using the
dataset’s spatial reference information. The resulting polygons are returned as a GeoDataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ds</strong> (<em>xarray.Dataset</em>) – The input dataset containing spatial reference information, including the GeoTransform parameters.</p></li>
<li><p><strong>epsg</strong> (<em>int</em><em>, </em><em>optional</em>) – The EPSG code for the coordinate reference system. If provided, the resulting GeoDataFrame is set
with this CRS.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A GeoDataFrame containing polygons representing each pixel in the grid, with an optional CRS set
if the <cite>epsg</cite> parameter is provided.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geopandas.GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method extracts the GeoTransform parameters from the dataset to compute the coordinates of each pixel.</p></li>
<li><p>The polygons are created using the <cite>shapely.geometry.box</cite> function to define the bounding box of each pixel.</p></li>
<li><p>If the <cite>epsg</cite> parameter is provided, the resulting GeoDataFrame will be reprojected to the specified CRS.</p></li>
<li><p>The order of the top and bottom pixel coordinates is corrected if necessary, based on the GeoTransform.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.extract_nldas_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extract_nldas_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridded_watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nldas_met_xarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nldas_elev_xarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.extract_nldas_timeseries" title="Link to this definition"></a></dt>
<dd><p>Extract NLDAS-2-2 timeseries data and station coordinates from a gridded watershed.</p>
<p>This function converts NLDAS-2-2 xarray datasets (meteorological and elevation) to pandas DataFrames for
locations within a gridded watershed. The extracted timeseries data is filtered based on the specified
threshold area, and the station coordinates (longitude, latitude, UTM x, UTM y, elevation) are returned
along with the timeseries data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gridded_watershed</strong> (<em>geopandas.GeoDataFrame</em>) – A GeoDataFrame representing the watershed with polygons for each sub-watershed.</p></li>
<li><p><strong>nldas_met_xarray</strong> (<em>xarray.Dataset</em>) – The xarray dataset containing NLDAS-2 meteorological timeseries data.</p></li>
<li><p><strong>nldas_elev_xarray</strong> (<em>xarray.Dataset</em>) – The xarray dataset containing NLDAS-2 elevation data.</p></li>
<li><p><strong>threshold_area</strong> (<em>float</em><em>, </em><em>optional</em>) – The minimum area for a sub-watershed to be considered. Default is 0, meaning all sub-watersheds
are included.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>The first element is a list of pandas DataFrames, each containing NLDAS-2 timeseries data for a sub-watershed.</p></li>
<li><p>The second element is a list of station coordinates, where each station is represented as
[longitude, UTM x, latitude, UTM y, elevation].</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (list of pandas.DataFrame, list of list of float)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses the ‘nearest’ method to select the closest data point in the NLDAS-2 xarray dataset
for each sub-watershed.</p></li>
<li><p>The elevation data is extracted from <cite>nldas_elev_xarray</cite> and combined with the timeseries data.</p></li>
<li><p>The station coordinates include both geographic (longitude, latitude) and UTM coordinates (x, y).</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.get_nldas_elevation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_nldas_elevation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.get_nldas_elevation" title="Link to this definition"></a></dt>
<dd><p>Download the NLDAS-2-2 elevation grid as a NetCDF file and return it as an xarray Dataset.</p>
<p>This method downloads the NLDAS-2-2 elevation data from a specified URL, clips it to the extent of the provided
watershed, reprojects it to the specified EPSG code, and returns the processed data as an xarray Dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>watershed</strong> (<em>geopandas.GeoDataFrame</em>) – The watershed for which the elevation data should be clipped.</p></li>
<li><p><strong>epsg</strong> (<em>int</em>) – The EPSG code for the desired projection of the output data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The processed elevation data clipped to the watershed extent and reprojected.
Returns <cite>None</cite> if there is an error during the download or processing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xarray.Dataset or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>requests.exceptions.RequestException</strong> – If there is an error downloading the NLDAS-2-2 elevation file.</p></li>
<li><p><strong>Exception</strong> – If there is any other error during the processing of the elevation data.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The NLDAS-2-2 elevation data is downloaded from NASA’s LDAS repository as a NetCDF file.</p></li>
<li><p>The downloaded dataset is processed to drop unnecessary variables, and the CRS is assigned using the <cite>epsg</cite> parameter.</p></li>
<li><p>The EPSG code 32662 (Equidistant Cylindrical projection) is used by default if no EPSG code is specified.</p></li>
<li><p>Caching the dataset or passing it as a variable rather than downloading it every time is a potential improvement.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.get_nldas_geom">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_nldas_geom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">hyriver_env_vars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.get_nldas_geom" title="Link to this definition"></a></dt>
<dd><p>Fetch NLDAS-2-2 data for a given geometry and time period, with optional caching and environment variable configuration.</p>
<p>This method retrieves NLDAS-2-2 data for a specified geometry and time range, using the <cite>pynldas2</cite> library.
It supports environment variables for controlling caching and verbosity, and optionally saves the resulting
xarray dataset to a NetCDF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geom</strong> (<em>str</em>) – The geometry (as a Polygon or MultiPolygon) for which the data is being requested.</p></li>
<li><p><strong>begin</strong> (<em>str</em>) – The start date for the data request in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>end</strong> (<em>str</em>) – The end date for the data request in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>epsg</strong> (<em>int</em>) – The EPSG code for the coordinate reference system of the geometry.</p></li>
<li><p><strong>write_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the resulting xarray dataset should be saved as a NetCDF file. If not provided, the
dataset is not saved to a file.</p></li>
<li><p><strong>**hyriver_env_vars</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments representing environment variables to control request/response caching and verbosity.
Supported variables include:
- HYRIVER_CACHE_NAME: Path to the caching SQLite database for asynchronous HTTP requests.
- HYRIVER_CACHE_NAME_HTTP: Path to the caching SQLite database for HTTP requests.
- HYRIVER_CACHE_EXPIRE: Expiration time for cached requests in seconds.
- HYRIVER_CACHE_DISABLE: Disable reading/writing from/to the cache.
- HYRIVER_SSL_CERT: Path to an SSL certificate file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dataset containing the NLDAS-2-2 data for the specified geometry and time period.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xarray.Dataset</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If an error occurs during the data retrieval or saving process.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method uses the <cite>NLDAS-2.get_bygeom</cite> function from the <cite>pynldas2</cite> library to fetch NLDAS-2 data for the specified geometry.</p></li>
<li><p>The geometry is automatically converted to a <cite>MultiPolygon</cite> if it is provided as a <cite>Polygon</cite>.</p></li>
<li><p>The HyRiver library should be cited as follows:
Chegini T, Li H-Y, Leung LR. 2021. HyRiver: Hydroclimate Data Retriever. Journal of Open Source Software 6: 3175.
DOI: 10.21105/joss.03175.</p></li>
<li><p>If the <cite>write_path</cite> is specified, the resulting dataset is saved as a NetCDF file at the given location.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.get_nldas_point">
<span class="sig-name descname"><span class="pre">get_nldas_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">centroids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">hyriver_env_vars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.get_nldas_point" title="Link to this definition"></a></dt>
<dd><p>Fetch NLDAS-2-2 data for a given set of coordinates and time period, with optional caching and environment variable configuration.</p>
<p>This method fetches NLDAS-2-2 data for specified centroids and a time range, utilizing the pynldas2 library. It supports
the use of environment variables for caching and verbosity settings and can handle optional CRS transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>centroids</strong> (<em>list</em><em> or </em><em>pandas.DataFrame</em>) – A list or DataFrame of coordinates (longitude, latitude) for which NLDAS-2-2 data is being requested.</p></li>
<li><p><strong>begin</strong> (<em>str</em>) – The start date for the data request in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>end</strong> (<em>str</em>) – The end date for the data request in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>epsg</strong> (<em>int</em><em>, </em><em>optional</em>) – The EPSG code for the coordinate reference system of the geometry. If not provided, defaults to the
EPSG code in <cite>self.meta</cite>.</p></li>
<li><p><strong>**hyriver_env_vars</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments representing environment variables to control request/response caching, verbosity,
and SSL settings. Some supported variables include:
- HYRIVER_CACHE_NAME: Path to the caching SQLite database for asynchronous HTTP requests.
- HYRIVER_CACHE_NAME_HTTP: Path to the caching SQLite database for HTTP requests.
- HYRIVER_CACHE_EXPIRE: Expiration time for cached requests in seconds.
- HYRIVER_CACHE_DISABLE: Disable reading/writing from/to the cache.
- HYRIVER_SSL_CERT: Path to an SSL certificate file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dataset containing the NLDAS-2-2 data for the specified coordinates and time period.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If an error occurs during the data fetching process.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses the <cite>NLDAS-2.get_bycoords</cite> method from the pynldas2 library to retrieve data.</p></li>
<li><p>If no EPSG code is provided, the default value is taken from <cite>self.meta[‘EPSG’]</cite>.</p></li>
<li><p>Caching behavior can be controlled through environment variables, which can be passed using <a href="#id7"><span class="problematic" id="id8">**</span></a>hyriver_env_vars.</p></li>
<li><p>The HyRiver library should be cited as follows:
Chegini T, Li H-Y, Leung LR. 2021. HyRiver: Hydroclimate Data Retriever. Journal of Open Source Software 6: 3175.
DOI: 10.21105/joss.03175.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.polygon_centroid_to_geographic">
<span class="sig-name descname"><span class="pre">polygon_centroid_to_geographic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">utm_crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geographic_crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EPSG:4326'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.polygon_centroid_to_geographic" title="Link to this definition"></a></dt>
<dd><p>Helper function from <cite>Aux</cite> Class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.met.met.MetProcessor.run_met_workflow">
<span class="sig-name descname"><span class="pre">run_met_workflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.met.met.MetProcessor.run_met_workflow" title="Link to this definition"></a></dt>
<dd><p>Execute the meteorological data workflow for a given watershed.</p>
<p>This method performs the following steps:
- Calculates the geographic centroid of the provided watershed.
- Retrieves meteorological data for the centroid from the NLDAS-2 dataset.
- Converts and writes the NLDAS-2 time series data to the specified format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>watershed</strong> (<em>shapely.geometry.Polygon</em>) – A Shapely polygon representing the watershed area. The geographic centroid of this polygon is used for
data retrieval.</p></li>
<li><p><strong>begin</strong> (<em>str</em>) – The start date for the meteorological data retrieval, in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>end</strong> (<em>str</em>) – The end date for the meteorological data retrieval, in ‘YYYY-MM-DD’ format.</p></li>
<li><p><strong>elev</strong> (<em>float</em>) – The elevation of the watershed centroid, used in the data processing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the retrieved and processed NLDAS-2-2 meteorological data for the specified centroid.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The geographic centroid of the watershed is calculated and used to retrieve the meteorological data from the
NLDAS-2-2 dataset.</p></li>
<li><p>The NLDAS-2-2 time series data is retrieved for the specified time range, processed, and written to the appropriate
format using the <cite>convert_and_write_nldas_timeseries</cite> method.</p></li>
<li><p>A cache is used for the NLDAS-2 data retrieval to improve efficiency.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.land.land.LandProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.land.land.</span></span><span class="sig-name descname"><span class="pre">LandProcessor</span></span><a class="headerlink" href="#pytRIBS.land.land.LandProcessor" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.land.land.LandProcessor.classify_vegetation_height">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classify_vegetation_height</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raster_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.land.land.LandProcessor.classify_vegetation_height" title="Link to this definition"></a></dt>
<dd><p>Classifies vegetation height raster based on user-defined thresholds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster_path</strong> (<em>str</em>) – Path to the input tree height raster.</p></li>
<li><p><strong>thresholds</strong> (<em>list</em><em> of </em><em>tuple</em>) – <p>Each tuple defines a range (min, max, class) and its class value.
For example: <code class="docutils literal notranslate"><span class="pre">[(0,</span> <span class="pre">5,</span> <span class="pre">1),</span> <span class="pre">(5,</span> <span class="pre">10,</span> <span class="pre">2),</span> <span class="pre">(10,</span> <span class="pre">15,</span> <span class="pre">3)]</span></code> will classify heights
from 0-5 as class 1, 5-10 as class 2, and so on.
- The min and max values must be increasing.
- On the first iteration, min is allowed to equal max; on subsequent iterations,</p>
<blockquote>
<div><p>min must be greater than the previous max.</p>
</div></blockquote>
</p></li>
<li><p><strong>output_path</strong> (<em>str</em>) – Path to save the classified raster.</p></li>
<li><p><strong>plot_result</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the classified image will be plotted. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>classified_image</strong> (<em>np.ndarray</em>) – The classified raster array.</p></li>
<li><p><strong>class_list</strong> (<em>list of dict</em>) – List of class attributes, where each dictionary represents a class range and its value.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the min value is not greater than the previous max value, or if min equals
    max on any iteration other than the first.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To classify vegetation height based on predefined thresholds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classified_data</span><span class="p">,</span> <span class="n">class_list</span> <span class="o">=</span> <span class="n">classify_vegetation_height</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">raster_path</span><span class="o">=</span><span class="s2">&quot;path/to/raster.tif&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">thresholds</span><span class="o">=</span><span class="n">thresholds</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">output_path</span><span class="o">=</span><span class="s2">&quot;path/to/output.tif&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">classified_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.land.land.LandProcessor.create_gdf_content">
<span class="sig-name descname"><span class="pre">create_gdf_content</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watershed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.land.land.LandProcessor.create_gdf_content" title="Link to this definition"></a></dt>
<dd><p>Create a dictionary containing geographic and parameter information for a watershed.</p>
<p>This function computes the geographic centroid of the given watershed polygon,
converts it to geographic coordinates (latitude and longitude), and then creates
a dictionary containing the number of parameters, the centroid’s geographic location,
the GMT time zone, and a list of parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>list</em><em> of </em><em>list</em>) – A list where each element is a list containing:
- parameter name (str): The name of the parameter (e.g., ‘VH’).
- raster path (str): The file path to the specified raster.
- file extension (str): The extension of the raster file (e.g., ‘.tif’).</p></li>
<li><p><strong>watershed</strong> (<em>GeoDataFrame</em><em> or </em><em>shapely.geometry.Polygon</em>) – The watershed boundary used to compute the centroid and derive geographic coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A dictionary containing the following key-value pairs:
- ‘Number of Parameters’ : int</p>
<blockquote>
<div><p>The number of parameters provided.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>’Latitude’<span class="classifier">float</span></dt><dd><p>The latitude of the watershed centroid in geographic coordinates.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>’Longitude’<span class="classifier">float</span></dt><dd><p>The longitude of the watershed centroid in geographic coordinates.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>’GMT Time Zone’<span class="classifier">int</span></dt><dd><p>The GMT time zone derived from the geographic coordinates.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>’Parameters’<span class="classifier">list</span></dt><dd><p>The original list of parameters provided.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To create a dictionary of geographic and parameter information for a watershed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;VH&#39;</span><span class="p">,</span> <span class="s1">&#39;path/to/raster1.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.tif&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;NDVI&#39;</span><span class="p">,</span> <span class="s1">&#39;path/to/raster2.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.tif&#39;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;path/to/watershed.shp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf_content</span> <span class="o">=</span> <span class="n">create_gdf_content</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">watershed</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gdf_content</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">],</span> <span class="n">gdf_content</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.land.land.LandProcessor.unsupervised_classification_naip">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unsupervised_classification_naip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NDVI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.land.land.LandProcessor.unsupervised_classification_naip" title="Link to this definition"></a></dt>
<dd><p>Perform unsupervised classification on a NAIP image using K-means clustering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_path</strong> (<em>str</em>) – Path to the NAIP image file.</p></li>
<li><p><strong>output_file_path</strong> (<em>str</em>) – Path to save the classified image.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Method to use for classification, either ‘NDVI’ or ‘true_color’. Default is ‘NDVI’.</p></li>
<li><p><strong>n_clusters</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of clusters for K-means clustering. Default is 5.</p></li>
<li><p><strong>plot_result</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the classified image will be plotted. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The classified image with the same dimensions as the input image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To classify an image using NDVI and 5 clusters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">classified_image</span> <span class="o">=</span> <span class="n">perform_kmeans_classification</span><span class="p">(</span><span class="s2">&quot;path/to/naip_image.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;path/to/output.tif&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">classified_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>To classify an image using true color with 3 clusters and no plotting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">classified_image</span> <span class="o">=</span> <span class="n">perform_kmeans_classification</span><span class="p">(</span><span class="s2">&quot;path/to/naip_image.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;path/to/output.tif&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;true_color&#39;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.mesh.mesh.</span></span><span class="sig-name descname"><span class="pre">Preprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outlet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snap_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose_mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir_proccesed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess" title="Link to this definition"></a></dt>
<dd><p>A class for preprocessing digital elevation models (DEMs) and extracting watershed and stream network data.</p>
<p>This class provides methods for preparing DEMs, setting up metadata, and processing elevation data to
extract watershed and stream network features. It uses the WhiteboxTools library for various geospatial
operations and supports setting verbose mode for logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outlet</strong> (<em>tuple</em><em> of </em><em>float</em>) – A tuple containing the outlet coordinates (longitude, latitude) used in the processing.</p></li>
<li><p><strong>snap_distance</strong> (<em>float</em>) – The distance used for snapping outlet points to the nearest flow path.</p></li>
<li><p><strong>threshold_area</strong> (<em>float</em>) – The area threshold used to identify streams in the flow accumulation raster.</p></li>
<li><p><strong>dem_path</strong> (<em>str</em>) – The file path to the digital elevation model (DEM) to be processed.</p></li>
<li><p><strong>verbose_mode</strong> (<em>bool</em>) – Flag to enable verbose mode for WhiteboxTools, controlling the amount of log output.</p></li>
<li><p><strong>meta</strong> (<em>dict</em>) – A dictionary containing metadata for the project, including ‘Name’, ‘EPSG’, and ‘Scenario’.</p></li>
<li><p><strong>dir_proccesed</strong> (<em>str</em><em>, </em><em>optional</em>) – Directory path for saving processed files. If not provided, defaults to ‘preprocessing’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>OSError</strong> – If there is an issue creating directories or accessing files.</p></li>
<li><p><strong>ValueError</strong> – If the EPSG code of the DEM does not match the project metadata and cannot be reconciled.</p></li>
</ul>
</dd>
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outlet</strong> (<em>tuple of float</em>) – The outlet coordinates used in the processing.</p></li>
<li><p><strong>snap_distance</strong> (<em>float</em>) – The distance used for snapping outlet points to the nearest flow path.</p></li>
<li><p><strong>threshold_area</strong> (<em>float</em>) – The area threshold used to identify streams.</p></li>
<li><p><strong>dem_preprocessing</strong> (<em>str</em>) – The absolute path to the digital elevation model (DEM) file.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – The directory where processed files are saved.</p></li>
<li><p><strong>meta</strong> (<em>dict</em>) – Metadata for the project, including ‘Name’, ‘EPSG’, and ‘Scenario’.</p></li>
<li><p><strong>wbt</strong> (<em>WhiteboxTools</em>) – Instance of WhiteboxTools for performing geospatial operations.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To initialize and preprocess a DEM:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meta_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Name&#39;</span><span class="p">:</span> <span class="s1">&#39;Watershed Project&#39;</span><span class="p">,</span> <span class="s1">&#39;EPSG&#39;</span><span class="p">:</span> <span class="mi">4326</span><span class="p">,</span> <span class="s1">&#39;Scenario&#39;</span><span class="p">:</span> <span class="s1">&#39;Base&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dem_preprocessor</span> <span class="o">=</span> <span class="n">DEMPreprocessor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">outlet</span><span class="o">=</span><span class="p">(</span><span class="mf">45.1234</span><span class="p">,</span> <span class="o">-</span><span class="mf">120.5678</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">snap_distance</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">threshold_area</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">dem_path</span><span class="o">=</span><span class="s2">&quot;path/to/dem.tif&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">verbose_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">meta</span><span class="o">=</span><span class="n">meta_data</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dem_preprocessor</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.clip_rasters">
<span class="sig-name descname"><span class="pre">clip_rasters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raster_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watershed_boundary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boundary'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.clip_rasters" title="Link to this definition"></a></dt>
<dd><p>Clip a list of rasters using the watershed boundary polygon or extent.</p>
<p>This method clips a list of rasters (e.g., filled DEM, flow direction raster, stream raster) using the
provided watershed boundary polygon. The clipping can be performed based on the polygon boundary, the
bounding box (extent), or both. The clipped rasters are saved to the specified output directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster_list</strong> (<em>list</em><em> of </em><em>str</em>) – A list of file paths to the rasters that need to be clipped.</p></li>
<li><p><strong>watershed_boundary</strong> (<em>str</em>) – The file path to the watershed boundary shapefile, which is used to clip the rasters.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – The clipping method to use. Options are:
- ‘boundary’: Clip rasters using the polygon boundary.
- ‘extent’: Clip rasters using the bounding box of the polygon.
- ‘both’: Perform both boundary and extent clipping.
Default is ‘boundary’.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The directory where the clipped rasters will be saved. If not provided, the default directory
<cite>{output_dir}/</cite> will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This method saves the clipped rasters to the specified output directory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.clip_streamline">
<span class="sig-name descname"><span class="pre">clip_streamline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watershed_boundary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.clip_streamline" title="Link to this definition"></a></dt>
<dd><p>Clip the streamlines shapefile by the watershed boundary polygon.</p>
<p>This method clips the streamlines from the provided stream shapefile using the watershed boundary polygon.
The clipped streamlines are saved to the specified output path, or a default path based on the project
metadata if no path is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stream_shapefile</strong> (<em>str</em>) – The file path to the streamlines shapefile to be clipped.</p></li>
<li><p><strong>watershed_boundary</strong> (<em>str</em>) – The file path to the watershed boundary shapefile, which will be used to clip the streamlines.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the clipped streamlines shapefile will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_streams.shp’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved clipped streamlines shapefile.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.convert_stream_raster_to_vector">
<span class="sig-name descname"><span class="pre">convert_stream_raster_to_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_direction_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.convert_stream_raster_to_vector" title="Link to this definition"></a></dt>
<dd><p>Create a shapefile of the stream network from the stream raster.</p>
<p>This method converts a stream raster into a vector format (shapefile) using the flow direction raster.
The resulting stream network is saved to the specified output path, or a default path based on the
project metadata if no path is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stream_raster</strong> (<em>str</em>) – The file path to the stream raster, which contains the stream network data.</p></li>
<li><p><strong>flow_direction_raster</strong> (<em>str</em>) – The file path to the flow direction raster (D8 method) used to convert the stream raster to vector format.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the stream network shapefile will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_streams.shp’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved stream network shapefile.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.create_outlet">
<span class="sig-name descname"><span class="pre">create_outlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_accumulation_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snap_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.create_outlet" title="Link to this definition"></a></dt>
<dd><p>Create a shapefile of the pour point (outlet) using specified coordinates, and snap it to the nearest flow path.</p>
<p>This method takes the pour point coordinates (x, y), creates a shapefile for the pour point, and snaps
the point to the nearest flow path within the specified snapping distance using the flow accumulation raster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em>) – The x-coordinate (longitude or easting) of the pour point.</p></li>
<li><p><strong>y</strong> (<em>float</em>) – The y-coordinate (latitude or northing) of the pour point.</p></li>
<li><p><strong>flow_accumulation_raster</strong> (<em>str</em>) – The file path to the flow accumulation raster used for snapping the pour point.</p></li>
<li><p><strong>snap_distance</strong> (<em>float</em>) – The distance used to snap the pour point to the nearest flow path.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the outlet shapefile will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_outlet.shp’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved shapefile of the snapped pour point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.extract_watershed_and_stream_network">
<span class="sig-name descname"><span class="pre">extract_watershed_and_stream_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outlet_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_streams_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.extract_watershed_and_stream_network" title="Link to this definition"></a></dt>
<dd><p>Extract the watershed and stream network from elevation data and save the results to specified paths.</p>
<p>This method processes elevation data to extract both the watershed and stream network. It performs a series of operations, including filling depressions, generating flow direction and accumulation rasters, identifying streams, and creating/clipping the watershed boundary and stream network. The results are saved to the provided file paths. Optionally, temporary files and directories can be cleaned up after processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outlet_path</strong> (<em>str</em>) – The file path where the outlet raster will be saved.</p></li>
<li><p><strong>boundary_path</strong> (<em>str</em>) – The file path where the watershed boundary shapefile will be saved.</p></li>
<li><p><strong>output_streams_path</strong> (<em>str</em>) – The file path where the clipped stream network shapefile will be saved.</p></li>
<li><p><strong>clean</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, temporary files and directories will be cleaned up after processing. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>OSError</strong> – If there is an issue creating directories or accessing files.</p></li>
<li><p><strong>ValueError</strong> – If the input parameters are not correctly specified.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.fill_depressions">
<span class="sig-name descname"><span class="pre">fill_depressions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.fill_depressions" title="Link to this definition"></a></dt>
<dd><p>Fill depressions (sinks) in the DEM within the watershed and save the filled DEM to the specified location.</p>
<p>This method uses the WhiteboxTools library to fill depressions (sinks) in the digital elevation model (DEM).
After the depressions are filled, the DEM is saved to the provided output path or a default path based on
the project metadata.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the filled DEM will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_filled.tif’</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved filled DEM file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To fill depressions and save the result to a specified file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filled_dem_path</span> <span class="o">=</span> <span class="n">dem_preprocessor</span><span class="o">.</span><span class="n">fill_depressions</span><span class="p">(</span><span class="n">output_path</span><span class="o">=</span><span class="s1">&#39;path/to/filled_dem.tif&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled DEM saved at: </span><span class="si">{</span><span class="n">filled_dem_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To use the default output path for saving the filled DEM:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filled_dem_path</span> <span class="o">=</span> <span class="n">dem_preprocessor</span><span class="o">.</span><span class="n">fill_depressions</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled DEM saved at: </span><span class="si">{</span><span class="n">filled_dem_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.generate_flow_accumulation_raster">
<span class="sig-name descname"><span class="pre">generate_flow_accumulation_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flow_direction_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.generate_flow_accumulation_raster" title="Link to this definition"></a></dt>
<dd><p>Generate a flow accumulation raster using the flow direction raster obtained from the D8 method.</p>
<p>This method creates a flow accumulation raster based on the flow direction raster, which was generated
using the D8 method. The generated flow accumulation raster is saved to the provided output path, or
a default path based on the project metadata if no path is specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_direction_raster</strong> (<em>str</em>) – The file path to the flow direction raster (D8 method) used to compute the flow accumulation.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the flow accumulation raster will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_flow_acc.tif’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved flow accumulation raster.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.generate_flow_direction_raster">
<span class="sig-name descname"><span class="pre">generate_flow_direction_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filled_dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.generate_flow_direction_raster" title="Link to this definition"></a></dt>
<dd><p>Generate a flow direction raster using the D8 method and save it to the specified location.</p>
<p>This method uses the WhiteboxTools library to create a flow direction raster based on the D8 flow algorithm.
The generated raster is saved to the provided output path, or a default path based on the project metadata
if no path is specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filled_dem</strong> (<em>str</em>) – The file path to the filled DEM (digital elevation model) that will be used to compute flow directions.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the flow direction raster will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_d8.tif’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved flow direction raster.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.generate_streams_raster">
<span class="sig-name descname"><span class="pre">generate_streams_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flow_accumulation_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.generate_streams_raster" title="Link to this definition"></a></dt>
<dd><p>Generate a stream raster from the flow accumulation raster based on the specified stream threshold.</p>
<p>This method creates a stream raster by extracting streams from the flow accumulation raster. The streams
are identified using the provided threshold area. The generated stream raster is saved to the specified
output path, or a default path based on the project metadata if no path is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_accumulation_raster</strong> (<em>str</em>) – The file path to the flow accumulation raster used to extract streams.</p></li>
<li><p><strong>threshold_area</strong> (<em>float</em>) – The area threshold (in map units) used to define streams in the flow accumulation raster.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the stream raster will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_stream.tif’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved stream raster.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.generate_watershed_boundary">
<span class="sig-name descname"><span class="pre">generate_watershed_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">watershed_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.generate_watershed_boundary" title="Link to this definition"></a></dt>
<dd><p>Generate the watershed boundary shapefile from the watershed raster.</p>
<p>This method extracts the watershed boundary from a given watershed mask (raster) and saves the boundary
as a shapefile. The watershed boundary is created by converting raster values to vector shapes, and the
result is saved to a specified output path or a default path based on the project metadata if no path is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>watershed_mask</strong> (<em>str</em>) – The file path to the watershed mask raster, which is used to delineate the watershed boundary.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the watershed boundary shapefile will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_watershed_bound.tif’</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.Preprocess.generate_watershed_mask">
<span class="sig-name descname"><span class="pre">generate_watershed_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flow_direction_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pour_point_shp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.Preprocess.generate_watershed_mask" title="Link to this definition"></a></dt>
<dd><p>Delineate the watershed in the form of a raster using the pour point shapefile and the flow direction raster.</p>
<p>This method uses the pour point shapefile and the flow direction raster (D8 flow direction) to delineate
the watershed area. The result is saved as a raster, which can be stored in a specified location or a
default location based on the project metadata if no path is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_direction_raster</strong> (<em>str</em>) – The file path to the flow direction raster (D8 method) used to delineate the watershed.</p></li>
<li><p><strong>pour_point_shp</strong> (<em>str</em>) – The file path to the shapefile containing the pour point(s) used to define the watershed outlet.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em>, </em><em>optional</em>) – The file path where the watershed mask raster will be saved. If not provided, the default path will be
<cite>‘{output_dir}/{project_name}_watershed_msk.tif’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The absolute path to the saved watershed mask raster.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.mesh.mesh.</span></span><span class="sig-name descname"><span class="pre">GenerateMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_raster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_watershed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_stream_network</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_outlet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'curvature'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh" title="Link to this definition"></a></dt>
<dd><p>A class for generating a locally refined triangular irregular network (TIN) mesh from raster data, watershed boundaries, and stream networks.</p>
<p>This class performs several operations to generate the TIN mesh, including extracting raster and wavelet information,
loading watershed boundaries, stream networks, and outlet points, and utilizing wavelet decomposition to refine the mesh
and incorporate significant details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_to_raster</strong> (<em>str</em>) – Path to the raster file used for extracting elevation data and wavelet analysis.</p></li>
<li><p><strong>path_to_watershed</strong> (<em>str</em>) – Path to the shapefile containing watershed boundary data.</p></li>
<li><p><strong>path_to_stream_network</strong> (<em>str</em>) – Path to the shapefile containing stream network data.</p></li>
<li><p><strong>path_to_outlet</strong> (<em>str</em>) – Path to the shapefile containing outlet point data.</p></li>
<li><p><strong>maxlevel</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum level for wavelet decomposition. If None, the maximum level is determined from the data.</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>normalizing_coeff</strong> (<em>float, optional</em>) – Coefficient used for normalizing wavelet coefficients, initially None.</p></li>
<li><p><strong>raster</strong> (<em>str</em>) – Path to the raster file.</p></li>
<li><p><strong>maxlevel</strong> (<em>int, optional</em>) – Maximum level for wavelet decomposition.</p></li>
<li><p><strong>watershed</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing watershed boundaries.</p></li>
<li><p><strong>stream_network</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing stream network data.</p></li>
<li><p><strong>outlet</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing outlet points.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.convert_coords_to_mesh">
<span class="sig-name descname"><span class="pre">convert_coords_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.convert_coords_to_mesh" title="Link to this definition"></a></dt>
<dd><p>Converts a set of coordinates into a 2D mesh using Delaunay triangulation.</p>
<p>This method takes an array of coordinates and converts them into a 2D mesh. The input coordinates
include x, y, and z values, along with an optional boundary code. While the boundary codes label
points in the mesh, they currently do not influence the mesh creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coords</strong> (<em>numpy.ndarray</em>) – An array where each row represents a point with x, y, z coordinates and a boundary code.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D mesh generated from the input coordinates using Delaunay triangulation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pyvista.PolyData</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IndexError</strong> – If the input <cite>coords</cite> array does not have at least four columns.</p></li>
<li><p><strong>ValueError</strong> – If the input <cite>coords</cite> array is empty or has incorrect dimensions.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The boundary codes provided in the <cite>coords</cite> array are stored with the mesh but do not currently affect
the triangulation process. Elevation data (z-values) are included in the mesh as a scalar field, which
could be used for subsequent analysis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.convert_points_to_gdf">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convert_points_to_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.convert_points_to_gdf" title="Link to this definition"></a></dt>
<dd><p>Helper function for converting points generated from <cite>extract_points_from_significant_details</cite> to a geopandas
data frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.distance_to_nearest_n">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">distance_to_nearest_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.distance_to_nearest_n" title="Link to this definition"></a></dt>
<dd><p>Calculates the average distance to the nearest <cite>n</cite> points for each point in a list.</p>
<p>This function uses a KD-tree to efficiently compute the distances between points and determine the
distances to the <cite>n</cite> nearest neighbors for each point. It returns the median and maximum distances to
these neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>list</em><em> of </em><em>tuples</em>) – A list of (x, y) coordinates representing the points to analyze.</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of nearest neighbors to consider for each point. Defaults to 6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>float : The median distance to the nearest <cite>n</cite> points for each point.</p></li>
<li><p>float : The maximum distance to the nearest <cite>n</cite> points for each point.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (float, float)</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the input <cite>points</cite> is empty or if <cite>n</cite> is less than 1.</p></li>
<li><p><strong>TypeError</strong> – If <cite>points</cite> is not a list of tuples or if <cite>n</cite> is not an integer.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method computes distances using a KD-tree, ensuring efficient calculations even with large datasets.
It calculates the distance to the nearest <cite>n</cite> points for each point in the input list, then returns the
median and maximum distances across all points.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.extract_points_from_significant_details">
<span class="sig-name descname"><span class="pre">extract_points_from_significant_details</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.extract_points_from_significant_details" title="Link to this definition"></a></dt>
<dd><p>Extracts significant points from wavelet decomposition details and processes them.</p>
<p>This method identifies significant details from wavelet decomposition at various levels, filters closely
spaced points, and generates additional points along stream paths. It combines these points with boundary
codes and interpolated elevations and returns the final set of points along with a buffered watershed geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>threshold</strong> (<em>float</em>) – The minimum threshold for identifying significant details in the wavelet decomposition.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>numpy.ndarray : Array of points with their x and y coordinates, elevations, and boundary codes.</p></li>
<li><p>geometry : Buffered watershed geometry, which can be used for further spatial analysis.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, geometry)</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AttributeError</strong> – If <cite>self.wavelet_packet</cite>, <cite>self.maxlevel</cite>, or other required attributes are not properly set.</p></li>
<li><p><strong>ValueError</strong> – If there are issues with the processing or filtering of points.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method first identifies the significant detail points in the wavelet decomposition at various levels,
then removes any points closer than the raster resolution. It generates points along stream paths and
combines all points with interpolated elevations and boundary codes. The method ensures that the points are
unique and returns them along with a buffered watershed geometry.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="p">,</span> <span class="n">buffered_watershed</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">extract_points_from_significant_details</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="go">[[x1, y1, elevation1, boundary_code1], [x2, y2, elevation2, boundary_code2], ...]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">buffered_watershed</span><span class="p">)</span>
<span class="go">&lt;Polygon geometry&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.extract_raster_and_wavelet_info">
<span class="sig-name descname"><span class="pre">extract_raster_and_wavelet_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.extract_raster_and_wavelet_info" title="Link to this definition"></a></dt>
<dd><p>Extracts information from a raster file and performs wavelet decomposition on the raster data.</p>
<p>This method reads the first band of the raster file, extracts its spatial information
(coordinates, transformation, bounds, width, and height), and computes the corresponding
meshgrids of x and y coordinates. It then performs a 2D wavelet decomposition on the raster
data and stores the resulting wavelet packet. The wavelet decomposition level is set or updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>data</strong> (<em>numpy.ndarray</em>) – The first band of the raster file as a 2D array.</p></li>
<li><p><strong>transform</strong> (<em>affine.Affine</em>) – The affine transformation matrix for the raster file.</p></li>
<li><p><strong>bounds</strong> (<em>rasterio.coords.BoundingBox</em>) – The bounding box of the raster file.</p></li>
<li><p><strong>width</strong> (<em>int</em>) – The width of the raster in pixels.</p></li>
<li><p><strong>height</strong> (<em>int</em>) – The height of the raster in pixels.</p></li>
<li><p><strong>x_grid</strong> (<em>numpy.ndarray</em>) – The x-coordinates of the raster data as a meshgrid.</p></li>
<li><p><strong>y_grid</strong> (<em>numpy.ndarray</em>) – The y-coordinates of the raster data as a meshgrid, adjusted based on the transformation.</p></li>
<li><p><strong>wavelet_packet</strong> (<em>pywt.WaveletPacket2D</em>) – The wavelet packet object containing the decomposed data.</p></li>
<li><p><strong>maxlevel</strong> (<em>int</em>) – The maximum level for wavelet decomposition, updated if necessary.</p></li>
<li><p><strong>normalizing_coeff</strong> (<em>float</em>) – The coefficient used to normalize wavelet coefficients, computed by <cite>find_max_maximum_coeffs()</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The y-coordinates (<cite>y_grid</cite>) are flipped if the transformation requires it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.filter_coords_within_geometry">
<span class="sig-name descname"><span class="pre">filter_coords_within_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_distance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.filter_coords_within_geometry" title="Link to this definition"></a></dt>
<dd><p>Filters and categorizes coordinates based on their position relative to a buffered watershed geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<em>numpy.ndarray</em>) – An array of shape (N, 2) representing coordinates to be filtered.</p></li>
<li><p><strong>buffer_distance</strong> (<em>float</em>) – The distance to buffer the watershed geometry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>all_coords</strong> (<em>numpy.ndarray</em>) – An array of filtered coordinates that include original, boundary, and inner boundary points.</p></li>
<li><p><strong>all_boundary_codes</strong> (<em>numpy.ndarray</em>) – An array of boundary codes corresponding to the filtered coordinates. Codes indicate whether a coordinate
is part of the original watershed (0), the outer boundary (1), or an updated outlet point (2).</p></li>
<li><p><strong>buffered_watershed</strong> (<em>shapely.geometry.Polygon</em>) – The buffered version of the original watershed geometry used for filtering.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function processes the original watershed geometry by applying a specified buffer distance and generates boundary points.
It finds coordinates within the original watershed and boundary points outside of it, adjusts coordinates based on proximity
to the updated outlet, and categorizes coordinates with boundary codes.</p>
<ul class="simple">
<li><p>Coordinates within the original watershed are assigned a boundary code of 0.</p></li>
<li><p>Coordinates on the outer boundary are assigned a boundary code of 1.</p></li>
<li><p>The outlet is adjusted to the nearest boundary point and given a boundary code of 2.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.find_max_average_coeffs">
<span class="sig-name descname"><span class="pre">find_max_average_coeffs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.find_max_average_coeffs" title="Link to this definition"></a></dt>
<dd><p>Calculates the maximum average coefficient from the wavelet packet decomposition.</p>
<p>This method computes the average of the absolute values of the vertical, horizontal, and diagonal
wavelet coefficients at each level of the wavelet decomposition. It then finds and returns the maximum
of these average coefficients across all decomposition levels.</p>
<p>The method uses the <cite>self.wavelet_packet</cite> attribute, which should be an instance of <cite>pywt.WaveletPacket2D</cite>
containing the decomposed data, and <cite>self.maxlevel</cite>, which defines the maximum level of decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum average coefficient across all levels of the wavelet decomposition.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AttributeError</strong> – If <cite>self.wavelet_packet</cite> or <cite>self.maxlevel</cite> is not properly set.</p></li>
<li><p><strong>ValueError</strong> – If there are issues with the wavelet coefficients or their dimensions.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The wavelet packet decomposition must be performed before calling this method. The method averages
the absolute values of the coefficients for the vertical (‘v’), horizontal (‘h’), and diagonal (‘d’)
details at each level of the decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.find_max_maximum_coeffs">
<span class="sig-name descname"><span class="pre">find_max_maximum_coeffs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.find_max_maximum_coeffs" title="Link to this definition"></a></dt>
<dd><p>Calculates the maximum coefficient from the wavelet packet decomposition.</p>
<p>This method computes the maximum of the absolute values of the vertical, horizontal, and diagonal
wavelet coefficients at each level of the wavelet decomposition. It then finds and returns the maximum
of these coefficients across all decomposition levels.</p>
<p>The method uses the <cite>self.wavelet_packet</cite> attribute, which should be an instance of <cite>pywt.WaveletPacket2D</cite>
containing the decomposed data, and <cite>self.maxlevel</cite>, which defines the maximum level of decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum coefficient across all levels of the wavelet decomposition.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AttributeError</strong> – If <cite>self.wavelet_packet</cite> or <cite>self.maxlevel</cite> is not properly set.</p></li>
<li><p><strong>ValueError</strong> – If there are issues with the wavelet coefficients or their dimensions.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The wavelet packet decomposition must be performed before calling this method. The method computes the
maximum of the absolute values of the coefficients for the vertical (‘v’), horizontal (‘h’), and diagonal (‘d’)
details at each level of the decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.generate_meshbuild_input_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_meshbuild_input_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.generate_meshbuild_input_file" title="Link to this definition"></a></dt>
<dd><p>Helper function that generates the input file to run with the MeshBuilder app.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.generate_points_along_stream">
<span class="sig-name descname"><span class="pre">generate_points_along_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.generate_points_along_stream" title="Link to this definition"></a></dt>
<dd><p>Generates points along a stream network ensuring they are sufficiently spaced from each other.</p>
<p>This method computes points along the stream network by interpolating positions at regular intervals
based on the resolution of the DEM (Digital Elevation Model). It ensures that these points are spaced
sufficiently from each other and from existing interior points by checking their distances from both the
stream network and any interior points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coords</strong> (<em>numpy.ndarray</em>) – An array of coordinates representing the existing points in the interior.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of points along the stream network, ensuring they are not too close to existing interior points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input <cite>coords</cite> is empty or has incorrect dimensions.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The stream network is traversed, and points are interpolated along each stream line at regular intervals
based on the DEM resolution. A KDTree is used to check distances between stream points and existing
interior points, ensuring the generated stream points are not too close to each other or to the interior points.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.get_extent">
<span class="sig-name descname"><span class="pre">get_extent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.get_extent" title="Link to this definition"></a></dt>
<dd><p>Returns extent (xmin, xmax, ymin, ymax) of dem data used in mesh generation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.interpolate_elevations">
<span class="sig-name descname"><span class="pre">interpolate_elevations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.interpolate_elevations" title="Link to this definition"></a></dt>
<dd><p>Interpolates elevation values for a set of geographic coordinates.</p>
<p>This method uses a regular grid interpolator to estimate elevation values at specified geographic
coordinates based on a given elevation data grid. It performs linear interpolation and handles
coordinates that fall outside the bounds of the grid by returning NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>points</strong> (<em>numpy.ndarray</em>) – An array of points where each row contains x and y coordinates for which elevation values are
to be interpolated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of interpolated elevation values corresponding to the input coordinates.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>points</cite> does not have exactly two columns (x and y coordinates).</p></li>
<li><p><strong>AttributeError</strong> – If <cite>self.data</cite> (the elevation data grid) or <cite>self.transform</cite> (the affine transformation matrix)
    is not properly set.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The interpolation is performed using a regular grid interpolator with linear interpolation. Points
outside the bounds of the elevation grid will return NaN as their elevation value. The input <cite>points</cite>
array must contain two columns, representing the x and y coordinates, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.partition_mesh">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">partition_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.partition_mesh" title="Link to this definition"></a></dt>
<dd><p>Partitions a mesh and produces a .reach file for parallel execution with tRIBS.</p>
<p>This function handles the partitioning of a mesh by interacting with Docker to build and process
the mesh based on the provided input files and partitioning parameters. It performs the following steps:</p>
<ul class="simple">
<li><p>Changes the working directory to the specified volume containing the mesh files.</p></li>
<li><p>Initializes and runs a Docker container to perform the mesh partitioning.</p></li>
<li><p>Executes the mesh partitioning workflow with the provided arguments.</p></li>
<li><p>Cleans up the Docker container and restores the working directory.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volume</strong> (<em>str</em>) – Path to the directory containing the .in and .points files for the mesh.</p></li>
<li><p><strong>partition_args</strong> (<em>list</em>) – <dl class="simple">
<dt>A list of arguments for partitioning:</dt><dd><ul>
<li><p>str : The name of the input file.</p></li>
<li><p>int : The number of nodes for partitioning.</p></li>
<li><p>int : The partition method (1-3).</p></li>
<li><p>str : The basename for output files.</p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function interacts with Docker to automate the mesh partitioning process for parallel execution
with tRIBS. It switches to the specified working directory, initializes a Docker container, runs the
mesh partitioning workflow, and then restores the original working directory after cleaning up.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.plot_mesh">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.plot_mesh" title="Link to this definition"></a></dt>
<dd><p>Helper function for plotting a PyVista mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.process_level">
<span class="sig-name descname"><span class="pre">process_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.process_level" title="Link to this definition"></a></dt>
<dd><p>Processes a specific level of wavelet decomposition to extract significant detail points using gradient or curvature.</p>
<p>This method examines the vertical, horizontal, and diagonal coefficients at the specified wavelet level,
identifies significant points based on a given threshold, and processes the points using either gradient or
curvature to find the most significant detail within each raster cell. If the cell is too small for gradient
or curvature computation, the centroid of the cell is used as the significant point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level</strong> (<em>int</em>) – The level of wavelet decomposition to process.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold value used to filter significant coefficients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An iterator of tuples containing the x and y coordinates of significant points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>iterator of tuples</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AttributeError</strong> – If <cite>self.wavelet_packet</cite>, <cite>self.data</cite>, <cite>self.x_grid</cite>, or <cite>self.y_grid</cite> is not properly set.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method processes each raster cell to find significant points by either gradient, curvature, or centroid,
depending on the <cite>self.feature_method</cite> attribute. The <cite>self.feature_method</cite> can be set to ‘gradient’,
‘curvature’, or default to ‘centroid’ if the method is not specified. The function filters coefficients
based on the normalized wavelet coefficients and a threshold value, ensuring only significant points are extracted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.remove_close_points">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">remove_close_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.remove_close_points" title="Link to this definition"></a></dt>
<dd><p>Removes points that are closer than a specified threshold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.mesh.GenerateMesh.write_point_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_point_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.mesh.GenerateMesh.write_point_file" title="Link to this definition"></a></dt>
<dd><p>Helper function for writing out points file.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.mesh.run_docker.</span></span><span class="sig-name descname"><span class="pre">MeshBuilderDocker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker" title="Link to this definition"></a></dt>
<dd><p>A class to manage the execution of the MeshBuilder tool in a Docker container.</p>
<p>This class facilitates setting up and running the MeshBuilder tool within a Docker container. It allows
for specifying the Docker image and volume path. The class manages the creation and lifecycle of Docker
containers for executing the MeshBuilder tool.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>volume_path</strong> (<em>str</em>) – Path to the directory that will be mounted as a volume inside the Docker container.</p>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>volume_path</strong> (<em>str</em>) – The path to the directory that is mounted as a volume inside the Docker container.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.clean_directory">
<span class="sig-name descname"><span class="pre">clean_directory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.clean_directory" title="Link to this definition"></a></dt>
<dd><p>Clean the directory by removing intermediate files.</p>
<p>This method removes all files in the specified volume directory, except those with extensions <cite>.in</cite>,
<cite>.points</cite>, <cite>.reach</cite>, or <cite>.out</cite>. It ensures that only intermediate files are deleted, leaving essential
files intact. If an error occurs while deleting a file, an error message is printed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If an error occurs while deleting a file, the exception is caught and a message is displayed.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method iterates through the files in the <cite>self.volume_path</cite> directory.</p></li>
<li><p>Files with the extensions <cite>.in</cite>, <cite>.points</cite>, <cite>.reach</cite>, and <cite>.out</cite> are preserved, while others are deleted.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.cleanup_container">
<span class="sig-name descname"><span class="pre">cleanup_container</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.cleanup_container" title="Link to this definition"></a></dt>
<dd><p>Stop and remove the Docker container.</p>
<p>This method stops the currently running Docker container and then removes it. If an error occurs during
stopping or removing the container, the exception is caught, and an error message is displayed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If an error occurs while stopping or removing the Docker container, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method assumes that <cite>self.container</cite> is a valid Docker container object that is running.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_command_in_container">
<span class="sig-name descname"><span class="pre">execute_command_in_container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">command</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_command_in_container" title="Link to this definition"></a></dt>
<dd><p>Execute a command in the running Docker container.</p>
<p>This method runs a specified shell command inside the currently running Docker container. The output
of the command is streamed and printed line by line. If the command runs successfully, a success message
is printed; otherwise, the exit code is displayed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>command</strong> (<em>str</em>) – The shell command to be executed inside the Docker container.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If there is an error while executing the command inside the Docker container, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The container must be running before executing this method.</p></li>
<li><p>The method uses the <cite>exec_run</cite> function from the Docker client to run the command and stream the output.</p></li>
<li><p>The command is executed in the <cite>/bin/bash</cite> shell of the container.</p></li>
<li><p>The exit code of the command is checked, and success or failure is reported accordingly.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_meshbuild_workflow">
<span class="sig-name descname"><span class="pre">execute_meshbuild_workflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">OPT_Part</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.execute_meshbuild_workflow" title="Link to this definition"></a></dt>
<dd><p>Execute the MeshBuilder workflow directly in the running Docker container.</p>
<p>This method executes a sequence of commands inside the running Docker container to perform the
MeshBuilder workflow. The workflow involves copying necessary files, running the MeshBuilder tool,
and executing partitioning using the METIS tool.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<em>str</em>) – Path to the .in file to be used by MeshBuilder.</p></li>
<li><p><strong>nn</strong> (<em>int</em>) – Number of computer nodes for partitioning.</p></li>
<li><p><strong>OPT_Part</strong> (<em>int</em>) – Partitioning method to be used.</p></li>
<li><p><strong>basename</strong> (<em>str</em>) – Simulation basename for the output files.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If an error occurs during the execution of the commands inside the Docker container, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The container must be running before this method is executed.</p></li>
<li><p>The method runs several shell commands in sequence inside the Docker container to set up the environment,
run MeshBuilder, and partition the mesh.</p></li>
<li><p>The commands are executed using the <cite>exec_run</cite> function from the Docker client with <cite>sh -c</cite> to ensure proper execution.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.initialize_docker_client">
<span class="sig-name descname"><span class="pre">initialize_docker_client</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.initialize_docker_client" title="Link to this definition"></a></dt>
<dd><p>Initialize the Docker client.</p>
<p>This method attempts to connect to the Docker daemon using the Docker client. If the connection is successful,
it assigns the client to the <cite>self.client</cite> attribute. If the connection fails, it prints an error message and
raises an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If the connection to the Docker daemon fails, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method assumes that Docker is properly installed and running on the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.pull_image">
<span class="sig-name descname"><span class="pre">pull_image</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.pull_image" title="Link to this definition"></a></dt>
<dd><p>Pull the Docker image.</p>
<p>This method pulls the Docker image specified by the <cite>self.image_name</cite> attribute from a Docker registry.
If the image pull is successful, a success message is printed. If an error occurs during the process,
it prints an error message and raises the exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If there is an error while pulling the Docker image, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method expects that the Docker client (<cite>self.client</cite>) has already been initialized and connected to
the Docker daemon, and that <cite>self.image_name</cite> contains the name of the Docker image to pull.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.run_container">
<span class="sig-name descname"><span class="pre">run_container</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.run_container" title="Link to this definition"></a></dt>
<dd><p>Run the Docker container with the specified volume.</p>
<p>This method starts a Docker container using the specified Docker image and mounts a volume from the
host to the container. The volume is mounted in read-write mode at the <cite>/meshbuild/data</cite> path inside
the container. The container is run with interactive terminal options (<cite>tty</cite> and <cite>stdin_open</cite>), and
it is detached from the terminal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If an error occurs while starting the Docker container, the exception is caught and re-raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>On Windows systems, the method replaces backslashes (<cite>`) in the volume path with forward slashes (</cite>/<a href="#id9"><span class="problematic" id="id10">`</span></a>).</p></li>
<li><p>The Docker client (<cite>self.client</cite>) must be initialized and connected to the Docker daemon before running this method.</p></li>
<li><p>The volume path (<cite>self.volume_path</cite>) must be correctly set to a valid host directory.</p></li>
<li><p>The container runs with <cite>/bin/bash</cite> as the entrypoint.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.mesh.run_docker.MeshBuilderDocker.start_docker_desktop">
<span class="sig-name descname"><span class="pre">start_docker_desktop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attempts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.mesh.run_docker.MeshBuilderDocker.start_docker_desktop" title="Link to this definition"></a></dt>
<dd><p>Ensure Docker is running, and if not, attempt to start it or prompt for installation.</p>
<p>This method checks if Docker is running by attempting to ping the Docker client. If Docker is not running,
it attempts to start Docker based on the current operating system. If Docker cannot be started after a
specified number of attempts, it prompts for installation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attempts</strong> (<em>int</em><em>, </em><em>optional</em>) – The current number of attempts made to start Docker, by default 0.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if Docker is running or successfully started, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>docker.errors.DockerException</strong> – If there is an issue connecting to Docker or starting it.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>On Windows, the method attempts to start Docker Desktop via PowerShell.</p></li>
<li><p>On macOS, the method uses the <cite>open</cite> command to launch Docker.</p></li>
<li><p>On Linux, the method uses <cite>systemctl</cite> to start the Docker service.</p></li>
<li><p>If the operating system is not recognized, the method prints an error and returns False.</p></li>
<li><p>The method will attempt to start Docker up to 5 times, waiting 15 seconds between each attempt.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.results.evaluate.Evaluate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.results.evaluate.</span></span><span class="sig-name descname"><span class="pre">Evaluate</span></span><a class="headerlink" href="#pytRIBS.results.evaluate.Evaluate" title="Link to this definition"></a></dt>
<dd><p>A collection of static methods for evaluating the performance of simulated data against observed data.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.evaluate.Evaluate.kling_gupta_efficiency">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kling_gupta_efficiency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulated</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.evaluate.Evaluate.kling_gupta_efficiency" title="Link to this definition"></a></dt>
<dd><p>Calculate the Kling-Gupta efficiency (KGE).</p>
<p>The Kling-Gupta efficiency is a metric that evaluates model performance based on correlation, variability, and bias. It ranges
from -∞ to 1, with 1 indicating perfect model performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observed</strong> (<em>numpy.ndarray</em>) – Array of observed data values.</p></li>
<li><p><strong>simulated</strong> (<em>numpy.ndarray</em>) – Array of simulated data values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Kling-Gupta efficiency coefficient.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.evaluate.Evaluate.nash_sutcliffe">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nash_sutcliffe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulated</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.evaluate.Evaluate.nash_sutcliffe" title="Link to this definition"></a></dt>
<dd><p>Calculate the Nash-Sutcliffe efficiency coefficient.</p>
<p>The Nash-Sutcliffe efficiency (NSE) is a normalized statistic that determines the relative magnitude of the residual variance
compared to the measured data variance. It ranges from -∞ to 1, with 1 indicating a perfect match between observed and simulated values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observed</strong> (<em>numpy.ndarray</em>) – Array of observed data values.</p></li>
<li><p><strong>simulated</strong> (<em>numpy.ndarray</em>) – Array of simulated data values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Nash-Sutcliffe efficiency coefficient.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.evaluate.Evaluate.percent_bias">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">percent_bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulated</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.evaluate.Evaluate.percent_bias" title="Link to this definition"></a></dt>
<dd><p>Calculate the percent bias.</p>
<p>The percent bias (PBIAS) measures the average tendency of the simulated data to be larger or smaller than the observed data.
Positive values indicate model underestimation, while negative values indicate model overestimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observed</strong> (<em>numpy.ndarray</em>) – Array of observed data values.</p></li>
<li><p><strong>simulated</strong> (<em>numpy.ndarray</em>) – Array of simulated data values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The percent bias.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.evaluate.Evaluate.root_mean_squared_error">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">root_mean_squared_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulated</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.evaluate.Evaluate.root_mean_squared_error" title="Link to this definition"></a></dt>
<dd><p>Calculate the root mean squared error (RMSE).</p>
<p>RMSE measures the square root of the average squared differences between observed and simulated values. It provides a measure
of how well the model predicts the observed data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observed</strong> (<em>numpy.ndarray</em>) – Array of observed data values.</p></li>
<li><p><strong>simulated</strong> (<em>numpy.ndarray</em>) – Array of simulated data values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The root mean squared error.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.results.read.</span></span><span class="sig-name descname"><span class="pre">Read</span></span><a class="headerlink" href="#pytRIBS.results.read.Read" title="Link to this definition"></a></dt>
<dd><p>Framework class for Results class</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.get_element_results">
<span class="sig-name descname"><span class="pre">get_element_results</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.get_element_results" title="Link to this definition"></a></dt>
<dd><p>Reads and processes element result files, and assigns them to <cite>self.element_results</cite>.</p>
<p>This method performs the following steps:
1. Constructs the directory path from the <cite>“outfilename”</cite> option in <cite>self.options</cite>.
2. Searches for files in the directory that match a certain pattern (<cite>*.pixel</cite>).
3. For each matching file, extracts the node ID from the filename.
4. Reads the content of each element file and creates a DataFrame of results.
5. Stores the results in a dictionary, with keys representing node IDs and the value being another dictionary</p>
<blockquote>
<div><p>containing the <cite>pixel</cite> DataFrame and a placeholder for <cite>waterbalance</cite>.</p>
</div></blockquote>
<p>The resulting dictionary is assigned to <cite>self.element_results</cite>. The key <cite>“invar”</cite> is used for the <cite>.invpixel</cite> file,
while node-specific files use their respective node IDs as keys.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This method updates the <cite>self.element_results</cite> attribute with the processed data.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.get_element_wb_dataframe">
<span class="sig-name descname"><span class="pre">get_element_wb_dataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.get_element_wb_dataframe" title="Link to this definition"></a></dt>
<dd><p>Generates a DataFrame with water balance results for a specified element.</p>
<p>This method retrieves water balance data for the given <cite>element_id</cite> and calculates various metrics based on
the pixel data. It uses attributes like porosity and element area from the spatial variables to compute
values such as saturated water, canopy snow water equivalent, and surface runoff.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>element_id</strong> (<em>int</em>) – Identifier for the element whose water balance data is to be retrieved.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>DataFrame containing water balance metrics with the following columns:
- <cite>Time</cite>: Time series of the data
- <cite>Unsat_mm</cite>: Unsaturated moisture in mm
- <cite>Sat_mm</cite>: Saturated moisture in mm, adjusted by porosity
- <cite>CanopySWE_mm</cite>: Canopy snow water equivalent in mm
- <cite>SWE_mm</cite>: Snow water equivalent in mm
- <cite>Canop_mm</cite>: Canopy storage in mm
- <cite>P_mm_h</cite>: Precipitation in mm/h
- <cite>ET_mm_h</cite>: Evapotranspiration in mm/h, adjusted for sublimation and evaporation
- <cite>Qsurf_mm_h</cite>: Surface runoff in mm/h
- <cite>Qunsat_mm_h</cite>: Unsaturated runoff in mm/h
- <cite>Qsat_mm_h</cite>: Saturated runoff in mm/h, adjusted by element area</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.get_mrf_results">
<span class="sig-name descname"><span class="pre">get_mrf_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mrf_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.get_mrf_results" title="Link to this definition"></a></dt>
<dd><p>Reads and processes the <cite>.mrf</cite> file containing model results.</p>
<p>If <cite>mrf_file</cite> is not provided, constructs the filename using the value of the <cite>“outhydrofilename”</cite> option
from <cite>self.options</cite>, combined with the runtime value, and appends <cite>“_00.mrf”</cite> to it.</p>
<p>This method performs the following steps:
1. Reads the column names and units from the first two rows of the <cite>.mrf</cite> file.
2. Loads the data into a DataFrame, skipping the first two rows which contain metadata.
3. Assigns the read column names to the DataFrame and adds the units as metadata.
4. Converts the <cite>Time</cite> column from hours since the start date to actual timestamps.
5. Updates the <cite>self.mrf</cite> attribute with the results, excluding extra time steps that may be included in the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mrf_file</strong> (<em>str</em><em>, </em><em>optional</em>) – The path to the <cite>.mrf</cite> file. If not provided, the filename is constructed based on the <cite>“outhydrofilename”</cite> and <cite>“runtime”</cite>
options from <cite>self.options</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This method updates the <cite>self.mrf</cite> attribute with the processed results DataFrame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.get_mrf_wb_dataframe">
<span class="sig-name descname"><span class="pre">get_mrf_wb_dataframe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.get_mrf_wb_dataframe" title="Link to this definition"></a></dt>
<dd><p>Generates a DataFrame with water balance results based on the MRF data.</p>
<p>This method computes water balance metrics from the MRF data using attributes such as drainage area, porosity,
and various MRF parameters. The resulting DataFrame includes calculated values for unsaturated moisture,
saturated moisture, snow water equivalent, and other hydrological metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataFrame containing water balance metrics with the following columns:
- <cite>Time</cite>: Time series of the data
- <cite>Unsat_mm</cite>: Unsaturated moisture in mm, calculated using the product of moisture storage, drainage weight, and porosity
- <cite>Sat_mm</cite>: Saturated moisture in mm, calculated using the product of drainage weight and porosity
- <cite>CanopySWE_mm</cite>: Canopy snow water equivalent in mm
- <cite>SWE_mm</cite>: Snow water equivalent in mm
- <cite>Canop_mm</cite>: Canopy storage in mm (currently set to 0 as it is not averaged)
- <cite>P_mm_h</cite>: Precipitation in mm/h
- <cite>ET_mm_h</cite>: Evapotranspiration in mm/h, adjusted for sublimation and evaporation
- <cite>Qsurf_mm_h</cite>: Surface runoff in mm/h, adjusted for drainage area
- <cite>Qunsat_mm_h</cite>: Unsaturated runoff in mm/h (currently set to 0; subject to validation)
- <cite>Qsat_mm_h</cite>: Saturated runoff in mm/h (currently set to 0; subject to validation)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.get_qout_results">
<span class="sig-name descname"><span class="pre">get_qout_results</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.get_qout_results" title="Link to this definition"></a></dt>
<dd><p>Reads the outlet discharge and water level data from a specified <cite>.qout</cite> file.</p>
<p>This method reads a <cite>.qout</cite> file containing outlet discharge and water level data, parses it into a DataFrame, and converts
the time information from hours since the start date to actual timestamps.</p>
<p>The <cite>.qout</cite> file is expected to be named by appending <cite>‘_Outlet.qout’</cite> to the value of the <cite>“outhydrofilename”</cite> option
from the <cite>self.options</cite> dictionary.</p>
<p>The method performs the following steps:
1. Reads the <cite>.qout</cite> file into a DataFrame with columns <cite>[‘Time_hr’, ‘Qstrm_m3s’, ‘Hlev_m’]</cite>.
2. Converts the <cite>Time_hr</cite> column from hours since the start date into actual timestamps.
3. Returns the DataFrame with an additional <cite>Time</cite> column representing the timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A DataFrame containing columns <cite>[‘Time_hr’, ‘Qstrm_m3s’, ‘Hlev_m’, ‘Time’]</cite>, where:
- <cite>Time_hr</cite> is the time in hours since the start date.
- <cite>Qstrm_m3s</cite> is the discharge in cubic meters per second.
- <cite>Hlev_m</cite> is the water level in meters.
- <cite>Time</cite> is the converted timestamp corresponding to each time step.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.read.Read.read_element_files">
<span class="sig-name descname"><span class="pre">read_element_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_results_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.read.Read.read_element_files" title="Link to this definition"></a></dt>
<dd><p>Reads a <cite>.pixel</cite> file from tRIBS model results and converts hourly time steps to datetime.</p>
<p>This method performs the following steps:
1. Reads the content of the specified <cite>.pixel</cite> file into a pandas DataFrame.
2. Converts the <cite>Time_hr</cite> column from hourly timesteps into datetime objects based on the starting date.
3. Adds a <cite>Time</cite> column to the DataFrame that contains the converted datetime values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>element_results_file</strong> (<em>str</em>) – Path to the <cite>.pixel</cite> file containing the tRIBS model results.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>DataFrame containing the results with an updated <cite>Time</cite> column reflecting datetime values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.results.visualize.Viz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.results.visualize.</span></span><span class="sig-name descname"><span class="pre">Viz</span></span><a class="headerlink" href="#pytRIBS.results.visualize.Viz" title="Link to this definition"></a></dt>
<dd><p>Framework class for Results Class</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.visualize.Viz.create_animation">
<span class="sig-name descname"><span class="pre">create_animation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gray'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_edge_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'red'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.visualize.Viz.create_animation" title="Link to this definition"></a></dt>
<dd><p>Create and save an animation based on a dictionary of DataFrames of tRIBS dynamic files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outfile</strong> (<em>str</em>) – The file path for saving the animation, format is determined from file extension (.mp4,.gif,.avi,.html).</p></li>
<li><p><strong>df_dict</strong> (<em>dict</em>) – A dictionary where keys represent animation frames and values are DataFrames to be plotted.</p></li>
<li><p><strong>frames</strong> (<em>iterable</em>) – Iterable containing keys from df_dict representing the frames to include in the animation.</p></li>
<li><p><strong>var</strong> (<em>str</em>) – The column name in DataFrames to be plotted.</p></li>
<li><p><strong>fps</strong> (<em>int</em><em>, </em><em>optional</em>) – Frames per second for the animation (default is 4).</p></li>
<li><p><strong>vlims</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Tuple containing minimum and maximum values for color normalization (default is None).</p></li>
<li><p><strong>nan_color</strong> (<em>str</em><em>, </em><em>optional</em>) – Color for NaN values in the plot (default is ‘gray’).</p></li>
<li><p><strong>nan_edge_color</strong> (<em>str</em><em>, </em><em>optional</em>) – Edge color for NaN values in the plot (default is ‘red’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If outfile is not a valid file path or frames is empty.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method creates an animation by iterating over frames specified in the frames parameter.</p></li>
<li><p>Each frame corresponds to a key in the df_dict dictionary, and the corresponding DataFrame is plotted.</p></li>
<li><p>NaN values in the DataFrame are flagged with the specified nan_color and nan_edge_color.</p></li>
<li><p>The animation format is dependent on the outfile extension with the specified frames per second (fps).</p></li>
</ul>
<p class="rubric">Example</p>
<p># Assuming instance is an instance of the class containing create_animation method
instance.create_animation(“animation.gif”, df_dict, frames=[‘0’,’1’,’2’,’3’], var=”ET”, fps=10)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.visualize.Viz.discrete_colormap">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">discrete_colormap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.visualize.Viz.discrete_colormap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.visualize.Viz.plot_water_balance">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_water_balance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">waterbalance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saved_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.visualize.Viz.plot_water_balance" title="Link to this definition"></a></dt>
<dd><p>Plots water balance components and saves the figure if a filename is provided.</p>
<p>This function creates a bar plot of water balance components, including precipitation (<cite>nP</cite>), runoff (<cite>nQ</cite>),
evapotranspiration (<cite>nET</cite>), and changes in storage (<cite>dS</cite>). It displays labels for the difference between
precipitation and the sum of other components. The plot is saved to a file if <cite>saved_fig</cite> is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waterbalance</strong> (<em>pd.DataFrame</em>) – DataFrame containing water balance components with columns:
- <cite>nP</cite>: Precipitation
- <cite>nQ</cite>: Runoff
- <cite>nET</cite>: Evapotranspiration
- <cite>dS</cite>: Change in storage</p></li>
<li><p><strong>saved_fig</strong> (<em>str</em><em>, </em><em>optional</em>) – Filename to save the figure. If not provided, the figure is not saved.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing the <cite>matplotlib.figure.Figure</cite> and <cite>matplotlib.axes.Axes</cite> objects for the plot.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The plot includes a stacked bar chart of <cite>nQ</cite>, <cite>nET</cite>, and <cite>dS</cite> with different colors.</p></li>
<li><p>Labels indicate the net difference between <cite>nP</cite> and the sum of <cite>dS</cite>, <cite>nQ</cite>, and <cite>nET</cite>.</p></li>
<li><p>The plot will automatically format the x-axis dates and display mean difference in the plot.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.results.waterbalance.WaterBalance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.results.waterbalance.</span></span><span class="sig-name descname"><span class="pre">WaterBalance</span></span><a class="headerlink" href="#pytRIBS.results.waterbalance.WaterBalance" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.waterbalance.WaterBalance.get_element_water_balance">
<span class="sig-name descname"><span class="pre">get_element_water_balance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.waterbalance.WaterBalance.get_element_water_balance" title="Link to this definition"></a></dt>
<dd><p>Calculate water balance for elements in the model.</p>
<p>This method iterates through element results and calculates the water balance for a specific node or key.
The user can specify the method for calculating the time frames over which the water balance is computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method</strong> (<em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – A string specifying the calculation method (‘full’ for the entire time period or ‘water_year’ for water year calculations),
or a list of custom date ranges in ‘YYYY-MM-DD’ format (e.g., [‘2024-01-01’, ‘2024-01-31’]).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method reads node results from the node output list and calculates the water balance for each element.</p></li>
<li><p>The <cite>method</cite> parameter determines how the time period is defined for water balance calculations:
- ‘full’: The full simulation period.
- ‘water_year’: Calculations based on the water year.
- A custom date range can be provided as a list of strings in ‘YYYY-MM-DD’ format.</p></li>
<li><p>The water balance results are stored in the <cite>self.element</cite> dictionary with the key <cite>“waterbalance”</cite> for each node.</p></li>
</ul>
<p class="rubric">Examples</p>
<ol class="arabic simple">
<li><p>Calculate full water balance:
&gt;&gt;&gt; get_element_water_balance(‘full’)</p></li>
<li><p>Calculate custom water balance for specific dates:
&gt;&gt;&gt; get_element_water_balance([‘2024-01-01’, ‘2024-01-31’])</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.results.waterbalance.WaterBalance.get_mrf_water_balance">
<span class="sig-name descname"><span class="pre">get_mrf_water_balance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.results.waterbalance.WaterBalance.get_mrf_water_balance" title="Link to this definition"></a></dt>
<dd><p>Calculate the water balance from watershed averaged results (<a href="#id11"><span class="problematic" id="id12">*</span></a>.mrf).</p>
<p>This method computes the water balance for the <a href="#id13"><span class="problematic" id="id14">*</span></a>.mrf file based on the specified method and stores the
result in the <cite>obj.mrf</cite> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method</strong> (<em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – A string specifying the calculation method (‘full’ for the entire time period, ‘water_year’ for water year calculations),
or a list of custom date ranges in ‘YYYY-MM-DD’ format (e.g., [‘2024-01-01’, ‘2024-01-31’]).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method uses the <cite>_run_mrf_water_balance</cite> internal function to compute the water balance based on the
provided method.</p></li>
<li><p>The resulting water balance is stored in the <cite>self.mrf</cite> dictionary with the key <cite>“waterbalance”</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<ol class="arabic simple">
<li><p>Calculate full MRF water balance:
&gt;&gt;&gt; get_mrf_water_balance(‘full’)</p></li>
<li><p>Calculate custom MRF water balance for specific dates:
&gt;&gt;&gt; get_mrf_water_balance([‘2024-01-01’, ‘2024-01-31’])</p></li>
</ol>
</dd></dl>

</dd></dl>

</section>
<section id="pytribs-shared-and-helper-classes">
<h1>pytRIBS Shared and Helper Classes<a class="headerlink" href="#pytribs-shared-and-helper-classes" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.shared.aux.</span></span><span class="sig-name descname"><span class="pre">Aux</span></span><a class="headerlink" href="#pytRIBS.shared.aux.Aux" title="Link to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.build">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">build_directory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tRIBS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ON'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cxx_flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-O2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.build" title="Link to this definition"></a></dt>
<dd><p>Run a tRIBS model simulation with optional arguments.</p>
<p>Run_simulation assumes that if relative paths are used then the binary and input file are collocated in the
same directory. That means for any keywords that depend on a relative path, must be specified from the directory
the tRIBS binary is executed. You can pass the location of the input file and executable as paths, in which case
the function copies the binary and input file to same directory and then deletes both after the model run is complete.
Optional arguments can be passed to store</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binary_path</strong> (<em>str</em>) – The path to the binary model executable.</p></li>
<li><p><strong>control_file_path</strong> (<em>str</em>) – The path to the input control file for the binary.</p></li>
<li><p><strong>optional_args</strong> (<em>str</em>) – Optional arguments to pass to the binary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The return code of the binary model simulation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.clean">
<span class="sig-name descname"><span class="pre">clean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.clean" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.convert_to_datetime">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convert_to_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">starting_date</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.convert_to_datetime" title="Link to this definition"></a></dt>
<dd><p>Returns a pandas date-time object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>starting_date</strong> (<em>str</em>) – The start date of a given model simulation, note needs to be in tRIBS format.</p>
</dd>
<dt class="field-even">Rtupe<span class="colon">:</span></dt>
<dd class="field-even"><p>A pandas Timestamp object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.discrete_cmap">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">discrete_cmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.discrete_cmap" title="Link to this definition"></a></dt>
<dd><p>Create an N-bin discrete colormap from the specified input map.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.fillnodata">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fillnodata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_pixel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.fillnodata" title="Link to this definition"></a></dt>
<dd><p>Fills nodata gaps in raster files based on a maximum search distance and optionally resamples the raster.</p>
<p>Parameters:
files (list): List of paths to raster files.
overwrite (bool): If True, the original files will be overwritten with filled data. If False, new files with “_filled” suffix will be created.
resample_pixel_size (float, optional): Target pixel size for resampling. If None, no resampling is performed.
resample_method (str, optional): Method for resampling. Choices are ‘nearest’, ‘bilinear’, ‘cubic’, etc. Defaults to ‘nearest’.
<a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs: Additional keyword arguments to be passed to rasterio.fill.fillnodata.</p>
<p>Note:
This function essentially wraps rasterio.fill.fillnodata and includes optional resampling.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.polygon_centroid_to_geographic">
<span class="sig-name descname"><span class="pre">polygon_centroid_to_geographic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">utm_crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geographic_crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EPSG:4326'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.polygon_centroid_to_geographic" title="Link to this definition"></a></dt>
<dd><p>Converts the centroid of a polygon from UTM coordinates to geographic coordinates (latitude and longitude),
and calculates the GMT offset of the local time zone at the centroid location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polygon</strong> (<em>shapely.geometry.Polygon</em>) – A Shapely Polygon object for which the centroid’s geographic coordinates are to be calculated.</p></li>
<li><p><strong>utm_crs</strong> (<em>str</em><em>, </em><em>optional</em>) – The EPSG code or CRS string of the UTM coordinate system. If not provided, it defaults to the CRS
specified in the <cite>self.meta[‘EPSG’]</cite> attribute.</p></li>
<li><p><strong>geographic_crs</strong> (<em>str</em><em>, </em><em>optional</em>) – The CRS string for the geographic coordinate system. Defaults to <cite>“EPSG:4326”</cite> for WGS84.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:
- <cite>lat</cite> : float</p>
<blockquote>
<div><p>Latitude of the centroid in decimal degrees.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt><cite>lon</cite><span class="classifier">float</span></dt><dd><p>Longitude of the centroid in decimal degrees.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>gmt_offset</cite><span class="classifier">int</span></dt><dd><p>GMT offset in hours based on the local time zone at the centroid location.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If no UTM CRS is found and <cite>self.meta[‘EPSG’]</cite> is <cite>None</cite>, a ValueError is raised.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses the <cite>Transformer</cite> class from the <cite>pyproj</cite> library to convert UTM coordinates to geographic coordinates.</p></li>
<li><p>The <cite>TimezoneFinder</cite> library is used to determine the local time zone based on latitude and longitude.</p></li>
<li><p>The GMT offset is calculated using the local time zone’s UTC offset.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">gmt_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon_centroid_to_geographic</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">utm_crs</span><span class="o">=</span><span class="s2">&quot;EPSG:32633&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">gmt_offset</span><span class="p">)</span>
<span class="go">(52.5167, 13.3833, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.print_tags">
<span class="sig-name descname"><span class="pre">print_tags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.print_tags" title="Link to this definition"></a></dt>
<dd><p>Prints .in options for a specified tag.
:param tag_name: Currently: “io”, input/output, “physical”, physical model params, “time”, time parameters,
“opts”, parameters for model options, “restart”, restart capabilities, “parallel”, parallel options.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">print_tags</span><span class="p">(</span><span class="s2">&quot;io&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.rename_file_with_date">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rename_file_with_date</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.rename_file_with_date" title="Link to this definition"></a></dt>
<dd><p>Renames a file by appending the provided date and ‘00’ for hours before the file extension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<em>str</em>) – The full path of the file to be renamed.</p></li>
<li><p><strong>date_str</strong> (<em>str</em>) – The date string in the format ‘YYYY-MM-DD’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new file name after renaming.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.run">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mpi_command</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tribs_flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.run" title="Link to this definition"></a></dt>
<dd><p>Run a tRIBS model simulation with optional arguments.</p>
<p>Run_simulation assumes that if relative paths are used then the binary and input file are collocated in the
same directory. That means for any keywords that depend on a relative path, must be specified from the directory
the tRIBS binary is executed. You can pass the location of the input file and executable as paths, in which case
the function copies the binary and input file to same directory and then deletes both after the model run is complete.
Optional arguments can be passed to store</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binary_path</strong> (<em>str</em>) – The path to the binary model executable.</p></li>
<li><p><strong>control_file_path</strong> (<em>str</em>) – The path to the input control file for the binary.</p></li>
<li><p><strong>optional_args</strong> (<em>str</em>) – Optional arguments to pass to the binary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The return code of the binary model simulation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.aux.Aux.utm_to_latlong">
<span class="sig-name descname"><span class="pre">utm_to_latlong</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">easting</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">northing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.aux.Aux.utm_to_latlong" title="Link to this definition"></a></dt>
<dd><p>Convert UTM coordinates to latitude and longitude using an EPSG code with pyproj.</p>
<p>Parameters:
easting (float): UTM easting coordinate.
northing (float): UTM northing coordinate.
epsg_code (int): EPSG code representing the UTM projection.</p>
<p>Returns:
tuple: A tuple containing latitude and longitude.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.shared.infile_mixin.Infile">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.shared.infile_mixin.</span></span><span class="sig-name descname"><span class="pre">Infile</span></span><a class="headerlink" href="#pytRIBS.shared.infile_mixin.Infile" title="Link to this definition"></a></dt>
<dd><p>Mixin for .in file parameters and definitions shared by both pytRIBS Classes Model &amp; Results.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.infile_mixin.Infile.create_input_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_input_file</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.infile_mixin.Infile.create_input_file" title="Link to this definition"></a></dt>
<dd><p>Creates a dictionary with tRIBS input options assigne to attribute input_options.</p>
<p>This function loads a dictionary of the necessary variables for a tRIBS input file. And is called upon
initialization. The dictionary is assigned as instance variable:input_options to the Class Simulation. Note
the templateVars file will need to be udpated if additional keywords are added to the .in file.</p>
<p>Each subdictionary has a tags key. With the tag indicating the role of the given option or variable in the model
simulation.</p>
<p>Tags:
time    - parameters related to model simulation times and time steps
mesh    - options for reading mesh
flow    - flow routing parameters
hydro    - options and physical parameters for hydrological components of modle
spatial   - input raster files and tables for bedrock, groundwater, landuse, and soil properties.
meterological    -  options for meterological data
output    - options and paths for model outputs
forecast - suite of options for forecast mode
stochastic    - suite of options for stochastic mode
restart   - options for restart functionality
parallel  - options for parallel functionality</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.shared.inout.</span></span><span class="sig-name descname"><span class="pre">InOut</span></span><a class="headerlink" href="#pytRIBS.shared.inout.InOut" title="Link to this definition"></a></dt>
<dd><p>Shared Class for managing reading and writing tRIBS files</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_ascii">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_ascii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_ascii" title="Link to this definition"></a></dt>
<dd><p>Returns dictionary containing ‘data’, ‘profile’, and additional metadata.
:param file_path: Path to ASCII (or other formats) raster.
:return: Dict</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_grid_data_file">
<span class="sig-name descname"><span class="pre">read_grid_data_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_grid_data_file" title="Link to this definition"></a></dt>
<dd><p>Returns dictionary with content of a specified Grid Data File (.gdf)
:param grid_type: string set to “weather”, “soil”, of “land”, with each corresponding to HYDROMETGRID, SCGRID, LUGRID
:return: dictionary containg keys and content: “Number of Parameters”,”Latitude”, “Longitude”,”GMT Time Zone”, “Parameters” (a  list of dicts)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_json">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_json" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_landuse_table">
<span class="sig-name descname"><span class="pre">read_landuse_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_landuse_table" title="Link to this definition"></a></dt>
<dd><p>Returns list of dictionaries for each type of landuse specified in the .ldt file.</p>
<p>Land Use Reclassification Table Structure (<a href="#id17"><span class="problematic" id="id18">*</span></a>.ldt, see tRIBS documentation for more details)
#Types  #Params
ID      a       b1       P      S       K       b2      Al       h      Kt      Rs      V LAI theta*_s theta*_t</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_met_sdf">
<span class="sig-name descname"><span class="pre">read_met_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_met_sdf" title="Link to this definition"></a></dt>
<dd><p>Returns list of met stations, where information from each station is stored in a dictionary.
:param file_path: Reads from options[“hydrometstations”][“value”], but can be separately specified.
:return: List of dictionaries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_met_station">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_met_station</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_met_station" title="Link to this definition"></a></dt>
<dd><p>Reads a meteorological station data file and processes it into a pandas DataFrame with a datetime index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_path</strong> (<em>str</em>) – Path to the meteorological station data file. The file should be in a space-separated format with columns for
year, month, day, and hour.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the meteorological data with a single ‘date’ column as a datetime index, and the remaining
columns from the input file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function expects the input file to have columns ‘Y’, ‘M’, ‘D’, and ‘H’ for year, month, day, and hour, respectively.</p></li>
<li><p>The columns for year, month, day, and hour are converted into a single ‘date’ column of datetime type.</p></li>
<li><p>The original columns ‘Y’, ‘M’, ‘D’, and ‘H’ are dropped from the DataFrame after the datetime conversion.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_point_files">
<span class="sig-name descname"><span class="pre">read_point_files</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_point_files" title="Link to this definition"></a></dt>
<dd><p>Returns Pandas dataframe of nodes or point used in tRIBS mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_precip_sdf">
<span class="sig-name descname"><span class="pre">read_precip_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_precip_sdf" title="Link to this definition"></a></dt>
<dd><p>Returns list of precip stations, where information from each station is stored in a dictionary.
:param file_path: Reads from options[“hydrometstations”][“value”], but can be separately specified.
:return: List of dictionaries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.read_precip_station">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_precip_station</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.read_precip_station" title="Link to this definition"></a></dt>
<dd><p>Returns pandas dataframe of precipitation from a station specified by file_path.
:param file_path: Flat file with columns Y M D H R
:return: Pandas dataframe</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_ascii">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_ascii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raster_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_ascii" title="Link to this definition"></a></dt>
<dd><p>Writes raster data and metadata from a dictionary to an ASCII raster file.
:param raster_dict: Dictionary containing ‘data’, ‘profile’, and additional metadata.
:param output_file_path: Output ASCII raster file path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_grid_data_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_grid_data_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_grid_data_file" title="Link to this definition"></a></dt>
<dd><p>Writes the content of a dictionary to a specified Grid Data File (.gdf)
:param grid_file: path to write out grid file to.
:param data: dictionary containing keys and content: “Number of Parameters”, “Latitude”, “Longitude”, “GMT Time Zone”, “Parameters” (a list of dicts)
:return: None</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_input_file">
<span class="sig-name descname"><span class="pre">write_input_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detailed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_input_file" title="Link to this definition"></a></dt>
<dd><p>Writes .in file for tRIBS model simulation.
:param self:
:param output_file_path: Location to write input file to.
:param detailed: Option to print input file with option descriptions and related info.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_landuse_table">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_landuse_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">landuse_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_landuse_table" title="Link to this definition"></a></dt>
<dd><p>Writes out Land Use Reclassification Table(<a href="#id19"><span class="problematic" id="id20">*</span></a>.ldt) file with the following format:
#Types  #Params
ID      a       b1       P      S       K       b2      Al       h      Kt      Rs      V LAI theta*_s theta*_t</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>landuse_list</strong> – List of dictionaries containing land information specified by .ldt structure above.</p></li>
<li><p><strong>file_path</strong> – Path to save <a href="#id21"><span class="problematic" id="id22">*</span></a>.sdt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_met_sdf">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_met_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">station_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_met_sdf" title="Link to this definition"></a></dt>
<dd><p>Writes a list of meteorological stations to a flat file (i.e. <a href="#id23"><span class="problematic" id="id24">*</span></a>.sdf file).
:param station_list: List of dictionaries containing station information.
:param output_file_path: Output flat file path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_met_station">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_met_station</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_met_station" title="Link to this definition"></a></dt>
<dd><p>Converts a DataFrame with ‘date’ and ‘PA’,’TD’ or ‘RH’ or ‘VP’,’XC’,’US’,’TA’,’TS’,’NR’ columns to flat file format.
See tRIBS documentation for more details on weather station data structure (i.e. <a href="#id25"><span class="problematic" id="id26">*</span></a>mdf files).
:param df: Pandas DataFrame with ‘date’ and ‘R’ columns.
:param output_file_path: Output flat file path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_node_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_node_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_node_file" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_point_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_point_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_point_file" title="Link to this definition"></a></dt>
<dd><p>Write a points file from a GeoDataFrame of nodes.</p>
<p>Parameters:
- nodes_gdf: GeoDataFrame</p>
<blockquote>
<div><p>GeoDataFrame containing nodes with ‘geometry’, ‘elevation’, and ‘bc’ columns.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>output_file: str</dt><dd><p>Path to the output points file.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:
None</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_precip_sdf">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_precip_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">station_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_precip_sdf" title="Link to this definition"></a></dt>
<dd><p>Writes a list of precip stations to a flat file.
:param station_list: List of dictionaries containing station information.
:param output_file_path: Output flat file path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.inout.InOut.write_precip_station">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_precip_station</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.inout.InOut.write_precip_station" title="Link to this definition"></a></dt>
<dd><p>Converts a DataFrame with ‘date’ and ‘R’ columns to flat file format with columns Y M D H R.
:param df: Pandas DataFrame with ‘date’ and ‘R’ columns.
:param output_file_path: Output flat file path.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.shared.shared_mixin.</span></span><span class="sig-name descname"><span class="pre">Shared</span></span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared" title="Link to this definition"></a></dt>
<dd><p>Shared methods betweens the pytRIBS Classes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.convert_to_datetime">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convert_to_datetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">starting_date</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.convert_to_datetime" title="Link to this definition"></a></dt>
<dd><p>Returns a pandas date-time object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>starting_date</strong> (<em>str</em>) – The start date of a given model simulation, note needs to be in tRIBS format.</p>
</dd>
<dt class="field-even">Rtupe<span class="colon">:</span></dt>
<dd class="field-even"><p>A pandas Timestamp object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.get_invariant_properties">
<span class="sig-name descname"><span class="pre">get_invariant_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.get_invariant_properties" title="Link to this definition"></a></dt>
<dd><p>Reads and processes invariant spatial properties based on the parallel mode setting.</p>
<p>This method handles the integration of spatial variables and Voronoi files depending on the mode specified
in the options. It merges parallel files or reads single files, computes weights, and loads Voronoi data.</p>
<p>The method does the following:
- Checks the <cite>parallelmode</cite> setting to determine if parallel processing is enabled.
- Merges parallel spatial files if in parallel mode, or reads a single spatial file if not.
- Computes weights based on the <cite>VAr</cite> column if in non-parallel mode.
- Loads Voronoi files based on the <cite>parallelmode</cite> setting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>parallelmode</cite> is set to 1, the method merges files with a <cite>_00i</cite> suffix and integrates spatial variables
based on runtime values.</p></li>
<li><p>If <cite>parallelmode</cite> is set to 0, it reads a single file based on the <cite>outfilename</cite> and <cite>runtime</cite> values,
and computes weights using the <cite>VAr</cite> column.</p></li>
<li><p>Voronoi files are read or merged based on the parallel mode setting.</p></li>
<li><p>If the <cite>parallelmode</cite> is not recognized, it prints an error message and sets the spatial variables and Voronoi data to <cite>None</cite>.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">get_invariant_properties</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are issues merging files or reading Voronoi data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.merge_parallel_spatial_files">
<span class="sig-name descname"><span class="pre">merge_parallel_spatial_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'_00d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colnames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.merge_parallel_spatial_files" title="Link to this definition"></a></dt>
<dd><p>Returns dictionary of combined spatial outputs for intervals specified by tRIBS option: “SPOPINTRVL”.
:param str suffix: Either _00d for dynamics outputs or _00i for time-integrated ouputs.
:param int dtime : Option to specify time step at which to start merge of files.
:param bool write: Option to write dataframes to file.
:param bool header: Set to False if headers are not provided with spatial files.
:param bool colnames: If header = False, column names can be provided for the dataframe–but it is expected the first column is ID.
:param bool single: If single = True then only spatial files specified at dtime are merged.
:return: Dictionary of pandas dataframes.
# TODO: Rename as get_spatial_files, and enable it to read parallel or serial results.
# TODO add a clean option to store .0 t0 .n files, then zip, probably would only want this if you are saving them out.
# TODO also return file names if saved out, also add serial version or a serial flag…so people can reaou</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.merge_parallel_voi">
<span class="sig-name descname"><span class="pre">merge_parallel_voi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">join</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.merge_parallel_voi" title="Link to this definition"></a></dt>
<dd><p>Returns geodataframe of merged vornoi polygons from parallel tRIBS model run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>join</strong> – Data frame of dynamic or integrated tRIBS model output (optional).</p></li>
<li><p><strong>save</strong> – Set to True to save geodataframe (optional, default True).</p></li>
<li><p><strong>result_path</strong> – Path to save geodateframe (optional, default OUTFILENAME).</p></li>
<li><p><strong>format</strong> – Driver options for writing geodateframe (optional, default = ESRI Shapefile)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>GeoDataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.mesh2vtk">
<span class="sig-name descname"><span class="pre">mesh2vtk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.mesh2vtk" title="Link to this definition"></a></dt>
<dd><p>Converts mesh data files into a VTK file format for visualization.</p>
<p>This function reads node, triangle, and elevation data from files and writes them to a VTK file.
The VTK file will be an unstructured grid dataset containing points and cells, with associated scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outfile</strong> (<em>str</em>) – Path to the output VTK file where the mesh data will be written.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>The function expects the following files in the directory specified by the ‘outfilename’ option:</dt><dd><ul>
<li><p>A node file with a <cite>.nodes</cite> extension containing node coordinates and boundary codes.</p></li>
<li><p>A triangle file with a <cite>.tri</cite> extension containing triangle vertex indices.</p></li>
<li><p>A z-file with a <cite>.z</cite> extension containing elevation values.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The node file should contain columns for x, y coordinates, and a boundary code.</p></li>
<li><p>The triangle file should contain columns for vertex indices of triangles.</p></li>
<li><p>The z-file should contain elevation values for each node.</p></li>
<li><p>The output VTK file will include point data (coordinates and elevations) and cell data (triangles).</p></li>
<li><p>Boundary codes are used to set NaN values in the altitude scalars in the VTK file.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">mesh2vtk</span><span class="p">(</span><span class="s1">&#39;output_mesh.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If the required node, triangle, or z files cannot be found in the specified directory.</p></li>
<li><p><strong>IndexError</strong> – If there is an issue reading data from the node, triangle, or z files, which may indicate file corruption.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.plot_mesh">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.plot_mesh" title="Link to this definition"></a></dt>
<dd><p>Plots a 3D mesh using PyVista with optional scalar data.</p>
<p>This method visualizes a mesh object, optionally using scalar data to color the mesh. It handles meshes
from a file path or PyVista object and allows for customizing the plot with additional keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>str</em><em> or </em><em>pv.PolyData</em>) – If a string is provided, it should be a path to a mesh file that will be read using PyVista. If a PyVista
<cite>PolyData</cite> object is provided, it will be used directly for plotting.</p></li>
<li><p><strong>scalar</strong> (<em>array-like</em><em>, </em><em>optional</em>) – Scalar data to be used for coloring the mesh. If not provided, it defaults to the ‘Elevation’ array of the
mesh. The scalar data must match the number of points or cells in the mesh.</p></li>
<li><p><strong>**kwargs</strong> (<em>keyword arguments</em>) – Additional keyword arguments passed to <cite>pyvista.Plotter.add_mesh</cite> for further customization of the plot.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A PyVista <cite>Plotter</cite> object configured to display the mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pv.Plotter</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>scalar</cite> is provided, it will be used to color the mesh. Closed points or cells (where ‘BoundaryCode’ is 1)
are set to NaN.</p></li>
<li><p>If the length of <cite>scalar</cite> matches the number of points, NaNs are assigned to closed points.</p></li>
<li><p>If the length of <cite>scalar</cite> matches the number of cells, NaNs are assigned to closed cells.</p></li>
<li><p>The plot camera is set to view from the top-down (xy plane) with north up.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;path_to_mesh_file.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plotter</span> <span class="o">=</span> <span class="n">plot_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="n">my_scalar_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the length of <cite>scalar</cite> does not match either the number of points or cells in the mesh.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.read_input_file">
<span class="sig-name descname"><span class="pre">read_input_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.read_input_file" title="Link to this definition"></a></dt>
<dd><p>Reads .in file for tRIBS model simulation and assigns values to options attribute.
:param file_path: Path to .in file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.read_node_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_node_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.read_node_list" title="Link to this definition"></a></dt>
<dd><p>Returns node list provide by .dat file.</p>
<p>The node list can be further modified or used for reading in element/pixel files and subsequent processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_path</strong> (<em>str</em>) – Relative or absolute file path to .dat file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of nodes specified by .dat file</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.read_reach_file">
<span class="sig-name descname"><span class="pre">read_reach_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.read_reach_file" title="Link to this definition"></a></dt>
<dd><p>Returns GeoDataFrame containing reaches from tRIBS model domain.
:param filename: Set to read _reach file specified from OUTFILENAME,but can be changed.
:return: GeoDataFrame</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Shared.read_voi_file">
<span class="sig-name descname"><span class="pre">read_voi_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Shared.read_voi_file" title="Link to this definition"></a></dt>
<dd><p>Returns GeoDataFrame containing voronoi polygons from tRIBS model domain.
:param filename: Set to read _reach file specified from OUTFILENAME,but can be changed.
:return: GeoDataFrame</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pytRIBS.shared.shared_mixin.Meta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pytRIBS.shared.shared_mixin.</span></span><span class="sig-name descname"><span class="pre">Meta</span></span><a class="headerlink" href="#pytRIBS.shared.shared_mixin.Meta" title="Link to this definition"></a></dt>
<dd><p>Class for project metadata.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="pytRIBS" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>